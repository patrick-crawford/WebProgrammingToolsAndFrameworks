"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[2357],{2342:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"JavaScript-Review/object-oriented-javascript","title":"Object Oriented JavaScript","description":"Object Oriented JavaScript","source":"@site/docs/JavaScript-Review/object-oriented-javascript.md","sourceDirName":"JavaScript-Review","slug":"/JavaScript-Review/object-oriented-javascript","permalink":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/object-oriented-javascript","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/JavaScript-Review/object-oriented-javascript.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"object-oriented-javascript","title":"Object Oriented JavaScript","sidebar_position":1,"description":"Object Oriented JavaScript"},"sidebar":"courseNotesSidebar","previous":{"title":"Hello World","permalink":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world"},"next":{"title":"Modern Syntax","permalink":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax"}}');var a=n(4848),r=n(8453);const i={id:"object-oriented-javascript",title:"Object Oriented JavaScript",sidebar_position:1,description:"Object Oriented JavaScript"},s="Object Oriented JavaScript",c={},h=[{value:"Object Literal Notation",id:"object-literal-notation",level:2},{value:"The &quot;class&quot; keyword",id:"the-class-keyword",level:2},{value:"Private Methods / Properties",id:"private-methods--properties",level:3},{value:"Getters / Setters",id:"getters--setters",level:3},{value:"Inheritance",id:"inheritance",level:3}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"object-oriented-javascript",children:"Object Oriented JavaScript"})}),"\n",(0,a.jsx)(t.p,{children:'Like many other modern languages, Javascript is "Object Oriented":'}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"Object-oriented programming is about modeling a system as a collection of objects, where each object represents some particular aspect of the system. Objects contain both functions (or methods) and data. An object provides a public interface to other code that wants to use it but maintains its own private, internal state; other parts of the system don\'t have to care about what is going on inside the object."'}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_programming",children:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_programming"})}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"object-literal-notation",children:"Object Literal Notation"}),"\n",(0,a.jsx)(t.p,{children:'The most simple and straight-forward way to create an object in JavaScript is to use "Object Literal Notation" (sometimes referred to as "object initializer" notation). The syntax for creating an object using this notation is as follows:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"let obj = {\n  property_1: value_1,\n  property_2: value_2,\n  // ...,\n  'property n': value_n,\n}; // properties can also be defined as a string`\n"})}),"\n",(0,a.jsx)(t.p,{children:"So, if we wanted to create an object with the following properties:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"name"})," (string)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"age"})," (number)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"occupation"})," (string)"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"and methods..."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"setName"}),' ("setter" to set a new value for the "name" property)']}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"setAge"}),' ("setter" to set a new value for the "age" property)']}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"getName"}),' ("getter" to get the current value of the "name" property)']}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"getAge"}),' ("getter" to get the current value of the "age" property)']}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:'using "Object Literal" notation, we would write the code:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"let architect = {\n  name: 'Joe',\n  age: 34,\n  occupation: 'Architect',\n\n  setName: function (newName) {\n    this.name = newName;\n  },\n\n  setAge: function (newAge) {\n    this.age = newAge;\n  },\n\n  getName: function () {\n    return this.name;\n  },\n\n  getAge: function () {\n    return this.age;\n  },\n};\n"})}),"\n",(0,a.jsx)(t.p,{children:"and access the data (properties) and functions (methods) using the following code, ie:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'console.log(architect.name); // "Joe"\n// or\nconsole.log(architect.getName()); // "Joe"\n'})}),"\n",(0,a.jsxs)(t.p,{children:["We must use the ",(0,a.jsx)(t.strong,{children:"\u201cthis\u201d"}),' keyword whenever we refer to one of the properties of the object inside one of it\u2019s methods. This is due to the fact that when a method is executed, "age" (for example) might already exist in the global scope, or within the scope of the function as a local variable. To be absolutely sure that we are referring to the correct "age" property of the current object, we must refer to the "execution context" - ie: the object that is actually making a call to this method. We know the object has an "age" property, so in order to be more specific about ',(0,a.jsx)(t.em,{children:"which"})," age variable that we want to change, we leverage the keyword ",(0,a.jsx)(t.strong,{children:"this"}),'. "this" will refer to the "execution context", ie: the object that called the function! So, ',(0,a.jsx)(t.strong,{children:'"this.age"'})," can be read literally as ",(0,a.jsx)(t.strong,{children:'"the age property on this object"'}),", which is exactly the property that we wish to edit."]}),"\n",(0,a.jsxs)(t.p,{children:['However, while "this" allows us to be specific with which ',(0,a.jsx)(t.strong,{children:"properties"})," that we refer to in our ",(0,a.jsx)(t.strong,{children:"methods"}),', it can lead to some confusing scenarios. For example, what if we added a new "outputNameDelay()" method to our architect object that writes the architect\'s name to the console after 1 second (1000 milliseconds):']}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"// ...\noutputNameDelay: function(){\n  setTimeout(function(){\n    console.log(this.name);\n  },1000);\n}\n// ...\narchitect.outputNameDelay(); // outputs undefined\n"})}),"\n",(0,a.jsxs)(t.p,{children:['Everything looks correct and we have made proper use of the "this", however because the setTimeout function is not executed as a method of our architect object, we end up with "undefined" as output to the console. There are a number of fixes for this issue (most noteworthy is the "arrow function" syntax - discussed further on) - one common way is to introduce a local variable (often named "that") into the current scope that ',(0,a.jsx)(t.strong,{children:'holds a reference to "this"'})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:'// ...\noutputNameDelay: function(){\n    let that = this;\n    setTimeout(function(){\n      console.log(that.name);\n    },1000);\n}\n// ...\narchitect.outputNameDelay(); // outputs "Joe"\n'})}),"\n",(0,a.jsx)(t.p,{children:'Now, we aren\'t using the "this" keyword from within the setTimeout() function, but rather "that" from our outputNameDelay function and everything works as it should! (ie, "that" points to architect, since it was the architect that invoked the outputNameDelay method).'}),"\n",(0,a.jsx)(t.h2,{id:"the-class-keyword",children:'The "class" keyword'}),"\n",(0,a.jsx)(t.p,{children:'If we wish to create multiple objects of the same "type" (ie: that have the same properties and methods, but with different values), we can leverage the "class" and "new" keywords, ie:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:'class Architect {\n  name;\n  age;\n  occupation = \'architect\'; // default value of "architect" for occupation\n\n  constructor(setName = \'\', setAge = 0) { // handle missing parameters with \'\' and 0\n    this.name = setName;\n    this.age = setAge;\n  }\n\n  setName(newName) {\n    this.name = newName;\n  }\n\n  setAge(newAge) {\n    this.age = newAge;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  getAge() {\n    return this.age;\n  }\n}\n\n// define new "architect objects using the "new" keyword with the "architect" class\n\nlet architect1 = new Architect(\'Joe\', 34);\nlet architect2 = new Architect(\'Mary\', 49);\n\n// samples of accessing properties and methods on both objects\n\nconsole.log(architect1.name); // "Joe"\n\nconsole.log(architect1.getName()); // "Joe"\nconsole.log(architect2.getName()); // "Mary"\n'})}),"\n",(0,a.jsx)(t.p,{children:'Here, we specify the properties (with default values), a "constructor" function to take initialization parameters, as well as specify all of the methods within the "class" block.'}),"\n",(0,a.jsx)(t.h3,{id:"private-methods--properties",children:"Private Methods / Properties"}),"\n",(0,a.jsx)(t.p,{children:'Notice how we can access the "name" property of the new Architect objects, directly (ie: without using the "getName()" function)? This is because by default, all properties and methods are "public". If we wish to mark properties as "private" (preventing the property from being accessed directly), we must add a "#" character to the beginning of the property or method name. For example:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"class Architect {\n  #name;\n  #age;\n  #occupation = 'architect'; // default value of \"architect\" for occupation\n\n  constructor(setName = '', setAge = 0) {\n    this.#name = setName;\n    this.#age = setAge;\n  }\n\n  #privateMethod() {\n    console.log(\"I'm a private method\");\n  }\n\n  setName(newName) {\n    this.#name = newName;\n  }\n\n  setAge(newAge) {\n    this.#age = newAge;\n  }\n\n  getName() {\n    return this.#name;\n  }\n\n  getAge() {\n    return this.#age;\n  }\n}\n\nlet architect1 = new Architect('Joe', 34);\nconsole.log(architect1.#name); // SyntaxError\n"})}),"\n",(0,a.jsx)(t.p,{children:'If we now try to access the "#name" property directly on an object created with this class, we get the following error:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"SyntaxError: Private field '#name' must be declared in an enclosing class\n"})}),"\n",(0,a.jsx)(t.h3,{id:"getters--setters",children:"Getters / Setters"}),"\n",(0,a.jsxs)(t.p,{children:['If we do wish to provide direct access to the "name" and "age" properties however, we can use ',(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set",children:'"setters"'})," and ",(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get",children:'"getters"'}),'. This way, we have more control over how the properties are manipulated and retrieved, internally to the class. For example, if we want controlled access to the "name" and "age" properties, we could use the following syntax:']}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"class Architect {\n  #name;\n  #age;\n  #occupation = 'architect'; // default value of \"architect\" for occupation\n\n  constructor(setName = '', setAge = 0) {\n    this.#name = setName;\n    this.#age = setAge;\n  }\n\n  #privateMethod() {\n    console.log(\"I'm a private method\");\n  }\n\n  set name(newName) {\n    this.#name = newName;\n  }\n\n  set age(newAge) {\n    this.#age = newAge;\n  }\n\n  get name() {\n    return this.#name;\n  }\n\n  get age() {\n    return this.#age;\n  }\n}\n\nlet architect1 = new Architect('Joe', 34);\nconsole.log(architect1.name); // Joe\n"})}),"\n",(0,a.jsx)(t.h3,{id:"inheritance",children:"Inheritance"}),"\n",(0,a.jsx)(t.p,{children:'A core principal of Object-Oriented Programming is "inheritance":'}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"a mechanism where you can to derive a class from another class for a hierarchy of classes that share a set of attributes and methods."'}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://stackify.com/oop-concept-inheritance",children:"https://stackify.com/oop-concept-inheritance"})}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:'In JavaScript, this is implemented via the "Prototype Chain":'}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"When it comes to inheritance, JavaScript only has one construct: objects. Each object has a private property which holds a link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype, and acts as the final link in this prototype chain."'}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain",children:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:['This is why we can access properties like "length" on a string, even though it is a primitive - it exists on the ',(0,a.jsx)(t.strong,{children:"prototype"})," of the built-in ",(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",children:"String Object"}),'. When we access the "length" property, a string primitive is automatically wrapped in a "String" object via a process known as ',(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Primitive",children:'"auto-boxing"'})," and we gain access to the property on the prototype."]}),"\n",(0,a.jsx)(t.p,{children:'To see this in action, let\'s modify the String prototype after we create a new string primitive. Once the string primitive is "auto-boxed" with the String object, we should have access to whatever we add on the prototype:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"let name = 'Thomas Anderson';\n\nString.prototype.sayHello = function () {\n  console.log('Hello from String!');\n};\n\nname.sayHello(); // Hello from String!\n"})}),"\n",(0,a.jsx)(t.p,{children:'Now that we know a little about how inheritance is implemented in JavaScript, you might be asking: "how does this work in our class definition?" and "do we have to modify the prototype of new objects directly?"'}),"\n",(0,a.jsx)(t.p,{children:'Fortunately, JavaScript has added the "extend" keyword so that we do not have to. For example, if our "architect" class inherits from a more generic "Job" class, we could write the code:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"class Job {\n  #name;\n  #age;\n\n  constructor(setName = '', setAge = 0) {\n    this.#name = setName;\n    this.#age = setAge;\n  }\n\n  set name(newName) {\n    this.#name = newName;\n  }\n\n  set age(newAge) {\n    this.#age = newAge;\n  }\n\n  get name() {\n    return this.#name;\n  }\n\n  get age() {\n    return this.#age;\n  }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:'for the "Job" class and add the new functionality for the "Architect" class using the following code:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"class Architect extends Job {\n  #occupation = 'architect';\n\n  constructor(setName = '', setAge = 0) {\n    super(setName, setAge); // invoke the \"parent\" constructor\n  }\n\n  #privateMethod() {\n    console.log(\"I'm a private method\");\n  }\n}\n\nlet architect1 = new Architect('Joe', 34);\nconsole.log(architect1.name);\n"})}),"\n",(0,a.jsx)(t.p,{children:'To verify that Job is indeed part of the "prototype chain" of the new architect1 object, we can use the familiar "prototype" test from above, ie:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"Job.prototype.sayHello = function () {\n  console.log('Hello from Job!');\n};\n\narchitect1.sayHello(); // Hello from Job!\n"})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var o=n(6540);const a={},r=o.createContext(a);function i(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);