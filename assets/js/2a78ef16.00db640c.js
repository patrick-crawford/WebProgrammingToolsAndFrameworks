"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[6241],{6992:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"Handling-Asynchronous-Code/promises-async-await","title":"Promises & Async / Await","description":"Promises & Async / Await","source":"@site/docs/Handling-Asynchronous-Code/promises-async-await.md","sourceDirName":"Handling-Asynchronous-Code","slug":"/Handling-Asynchronous-Code/promises-async-await","permalink":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/promises-async-await","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/Handling-Asynchronous-Code/promises-async-await.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"promises-async-await","title":"Promises & Async / Await","sidebar_position":2,"description":"Promises & Async / Await"},"sidebar":"courseNotesSidebar","previous":{"title":"Callbacks","permalink":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/callbacks"},"next":{"title":"Example Code","permalink":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/example-code"}}');var s=n(4848),a=n(8453);const i={id:"promises-async-await",title:"Promises & Async / Await",sidebar_position:2,description:"Promises & Async / Await"},r="Promises & Async / Await",c={},l=[{value:"Callback Review",id:"callback-review",level:2},{value:"Promises",id:"promises",level:2},{value:"Resolve &amp; Then",id:"resolve--then",level:3},{value:"Adding Data",id:"adding-data",level:3},{value:"Reject &amp; Catch",id:"reject--catch",level:3},{value:"Putting it Together",id:"putting-it-together",level:3},{value:"Async &amp; Await",id:"async--await",level:2},{value:"Putting it Together (again)",id:"putting-it-together-again",level:3},{value:"Using Await",id:"using-await",level:3}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"promises--async--await",children:"Promises & Async / Await"})}),"\n",(0,s.jsxs)(t.p,{children:["As we have seen in our ",(0,s.jsx)(t.a,{href:"/Handling-Asynchronous-Code/callbacks",children:'"callbacks"'}),' discussion, JavaScript is "asynchronous" in nature. Code can be written to respond to events or wait for tasks to complete before executing. One way of handling such situations was to enclose our "follow up" logic in a function that may be passed to another function to be executed (typically, after some asynchronous logic has completed such as connecting to a database, or reading a file).']}),"\n",(0,s.jsx)(t.h2,{id:"callback-review",children:"Callback Review"}),"\n",(0,s.jsx)(t.p,{children:"As a quick review of the callback logic discussed earlier, consider the following three functions:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"// output \"A\" after a random time between 0 & 3 seconds\nfunction outputA() {\n  let randomTime = Math.floor(Math.random() * 3000) + 1;\n\n  setTimeout(() => {\n    console.log('A');\n  }, randomTime);\n}\n\n// output \"B\" after a random time between 0 & 3 seconds\nfunction outputB() {\n  let randomTime = Math.floor(Math.random() * 3000) + 1;\n\n  setTimeout(() => {\n    console.log('B');\n  }, randomTime);\n}\n\n// output \"C\" after a random time between 0 & 3 seconds\nfunction outputC() {\n  let randomTime = Math.floor(Math.random() * 3000) + 1;\n\n  setTimeout(() => {\n    console.log('C');\n  }, randomTime);\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"If we were to execute them in order, ie:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"outputA();\noutputB();\noutputC();\n"})}),"\n",(0,s.jsx)(t.p,{children:'we would have no idea which letter would be output to the console first ("A", "B", or "C"), since each function takes a random amount of time to complete. If however, we wanted to be absolutely sure that the output of the code is in the correct order ("A", "B", "C") regardless of how long it takes each function to execute, we must ensure that the "follow up" functions are passed as parameters to the functions with the asynchronous logic (ie: "callbacks"). This case is more complicated because we have 3 functions, however it can still be achieved using the following code:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"// output \"A\" after a random time between 0 & 3 seconds\nfunction outputA(firstCallback, secondCallback) {\n  let randomTime = Math.floor(Math.random() * 3000) + 1;\n\n  setTimeout(() => {\n    console.log('A');\n    firstCallback(secondCallback);\n  }, randomTime);\n}\n\n// output \"B\" after a random time between 0 & 3 seconds\nfunction outputB(lastCallback) {\n  let randomTime = Math.floor(Math.random() * 3000) + 1;\n\n  setTimeout(() => {\n    console.log('B');\n    lastCallback();\n  }, randomTime);\n}\n\n// output \"C\" after a random time between 0 & 3 seconds\nfunction outputC() {\n  let randomTime = Math.floor(Math.random() * 3000) + 1;\n\n  setTimeout(() => {\n    console.log('C');\n  }, randomTime);\n}\n\n// invoke the functions in order\n\noutputA(outputB, outputC);\n"})}),"\n",(0,s.jsx)(t.p,{children:"In the above code, we have ensured the correct flow of execution of the three functions by passing both follow up functions to the first function as parameters. The final function is then passed to the second function as a callback, so that it may be executed in the right order."}),"\n",(0,s.jsx)(t.p,{children:'While this does indeed work to solve the intended problem (getting the output to happen in order: "A", "B" then "C"), we have created some code which is difficult to follow, maintain and scale. For example, what happens when we add an "outputD()" function? We would need to pass it as well to the outputA() function as a parameter, only to get passed down the chain until it is executed in the correct context (for example, after outputC() has completed). As you can imagine, this creates a problem in our code and leaves us asking: "is there a better way?"'}),"\n",(0,s.jsx)(t.h2,{id:"promises",children:"Promises"}),"\n",(0,s.jsx)(t.h3,{id:"resolve--then",children:"Resolve & Then"}),"\n",(0,s.jsxs)(t.p,{children:["Fortunately, JavaScript has the notion of the ",(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",children:'"Promise"'})}),' that can help us deal with this type of situation. Put simply, a promise object is used for asynchronous computations (like the situation in the example above) and represents a value which may be available now, or in the future, or never. Basically, what this means is that we can place our asynchronous code inside a promise object as a function with specific parameters ("resolve" and "reject"). When our code is complete, we invoke the ',(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve",children:'"resolve" function'})," and if our code encounters an error, we can invoke the ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject",children:'"reject" function'}),". We can handle both of these situations later with the ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then",children:".then()"})," method or (in the case of an error that we wish to handle) the ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch",children:".catch()"})," method. To see how this concept is implemented in practice, consider the following addition to the outputA() method from above:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'// output "A" after a random time between 0 & 3 seconds\nfunction outputA() {\n  let randomTime = Math.floor(Math.random() * 3000) + 1;\n\n  return new Promise((resolve, reject) => {\n    // place our code inside a "Promise" function\n    setTimeout(() => {\n      console.log(\'A\');\n      resolve(); // call "resolve" because we have completed the function successfully\n    }, randomTime);\n  });\n}\n\n// call the outputA function and when it is "resolved", output a confirmation to the console\n\noutputA().then(() => {\n  console.log(\'outputA resolved!\');\n});\n'})}),"\n",(0,s.jsxs)(t.p,{children:['Our "outputA()" function still behaves as it did before (outputs "A" to the console after a random period of time). However, our outputA() function now additionally returns a ',(0,s.jsx)(t.strong,{children:"new Promise"})," object that contains all of our asynchronous logic and its status. The container function for our logic always uses the two parameters mentioned above, ie: ",(0,s.jsx)(t.strong,{children:"resolve"})," and ",(0,s.jsx)(t.strong,{children:"reject"}),". By invoking the ",(0,s.jsx)(t.strong,{children:"resolve"}),' method we are placing the promise into the fulfilled state, meaning that the operation completed successfully and the character "A" was successfully output to the console. We can respond to this situation using the ',(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then",children:'"then"'})," function on the returned promise object to execute some code ",(0,s.jsx)(t.strong,{children:"after"})," the asynchronous operation is complete! This gives us a mechanism to react to asynchronous functions that have completed successfully so that we can perform additional tasks."]}),"\n",(0,s.jsx)(t.h3,{id:"adding-data",children:"Adding Data"}),"\n",(0,s.jsxs)(t.p,{children:["Now that we have the promise structure in place and are able to ",(0,s.jsx)(t.strong,{children:'"resolve"'})," the promise when it has completed it's task and ",(0,s.jsx)(t.strong,{children:'"then"'}),' execute another function using the returned promise object (as above), we can begin to think about how to pass data from the asynchronous function to the "then" method. Fortunately, it only requires a little tweak to the above the above example to enable this functionality:']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'// output "A" after a random time between 0 & 3 seconds\nfunction outputA() {\n  let randomTime = Math.floor(Math.random() * 3000) + 1;\n\n  return new Promise((resolve, reject) => {\n    // place our code inside a "Promise" function\n    setTimeout(() => {\n      console.log(\'A\');\n      resolve(\'outputA resolved!\'); // call "resolve" because we have completed the function successfully\n    }, randomTime);\n  });\n}\n\n// call the outputA function and when it is "resolved", output a confirmation to the console\n\noutputA().then((data) => {\n  console.log(data);\n});\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Notice how we are able to invoke the ",(0,s.jsx)(t.strong,{children:"resolve()"}),' function with a single parameter that stores some data (in this case a string with the text "outputA resolved!"). This is typically where we would place our freshly returned data from an asynchronous call to a web service / database, etc. The reason for this is that we will have access to it as the first parameter to the anonymous function declared inside the ',(0,s.jsx)(t.strong,{children:".then"})," method and this is the perfect place to process the data."]}),"\n",(0,s.jsx)(t.h3,{id:"reject--catch",children:"Reject & Catch"}),"\n",(0,s.jsx)(t.p,{children:'It is not always safe to assume that our asynchronous calls will complete successfully. What if we\'re in the middle of a request and our connection is dropped or a database connection fails? To ensure that we handle this type of scenario gracefully, we can invoke the "reject" method instead of the "resolve" method and provide a reason why our asynchronous operation failed. This causes the promise to be in a "rejected" state and the ".catch" function will be invoked, where we can gracefully handle the error. The typical syntax for handling both "then" and "catch" in a promise is as follows:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'// output "A" after a random time between 0 & 3 seconds\nfunction outputA() {\n  let randomTime = Math.floor(Math.random() * 3000) + 1;\n\n  return new Promise((resolve, reject) => {\n    // place our code inside a "Promise" function\n    setTimeout(() => {\n      console.log(\'-\');\n      reject(\'outputA rejected!\'); // call "reject" because the function encountered an error\n    }, randomTime);\n  });\n}\n\n// call the outputA function and when it is "resolved" or "rejected, output a confirmation to the console\n\noutputA()\n  .then((data) => {\n    console.log(data);\n  })\n  .catch((reason) => {\n    console.log(reason);\n  });\n'})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"NOTE"}),': Calling "resolve()" or "reject()" won\'t immediately exit the promise and invoke the related ".then()" or ".catch()" callback - it simply puts the promise in a "resolved" or "rejected" state and code immediately following the statement will still run, ie:']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'// ...\nreject();\nconsole.log(\'I will still be executed\');\nresolve(); // This promise will not be "resolved", since the resolve() call came after reject()\n// this also works the other way around.  A promise has been "settled" once reject or resolve has been called\n// ...\n'})}),"\n",(0,s.jsx)(t.p,{children:'If we want to immediately exit the function and prevent further execution of the code within the promise, we can invoke the "return" statement, immediately following the "resolve()" or "reject()" call, ie:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"// ...\nreject();\nreturn;\nconsole.log('I will not be executed');\n// ...\n"})}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"putting-it-together",children:"Putting it Together"}),"\n",(0,s.jsx)(t.p,{children:'Now that we know how the promise object and pattern can help us manage our asynchronous code, let\'s loop back to our original problem - ensuring that "A", "B" and "C" are output in the correct order when invoking the "outputA()", "outputB()" and "outputC()" functions, respectfully.'}),"\n",(0,s.jsxs)(t.p,{children:["To make it more interesting, we will alter our code such that each of the functions ",(0,s.jsx)(t.strong,{children:"resolve"})," with the value if the ",(0,s.jsx)(t.em,{children:"randomTime"})," is ",(0,s.jsx)(t.em,{children:"odd"})," and ",(0,s.jsx)(t.strong,{children:"reject"})," with an error if ",(0,s.jsx)(t.em,{children:"randomTime"})," is ",(0,s.jsx)(t.em,{children:"even"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"// output \"A\" after a random time between 0 & 3 seconds\nfunction outputA() {\n  let randomTime = Math.floor(Math.random() * 3000) + 1;\n\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      randomTime % 2 ? resolve('A') : reject('Error with outputA()');\n    }, randomTime);\n  });\n}\n\n// output \"B\" after a random time between 0 & 3 seconds\nfunction outputB() {\n  let randomTime = Math.floor(Math.random() * 3000) + 1;\n\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      randomTime % 2 ? resolve('B') : reject('Error with outputB()');\n    }, randomTime);\n  });\n}\n\n// output \"C\" after a random time between 0 & 3 seconds\nfunction outputC() {\n  let randomTime = Math.floor(Math.random() * 3000) + 1;\n\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      randomTime % 2 ? resolve('C') : reject('Error with outputC()');\n    }, randomTime);\n  });\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If we wish to use the promises correctly to output the values in order ",(0,s.jsx)(t.strong,{children:"and"})," correctly handles errors, our code looks like the following (this is known as ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#chaining",children:'promise "chaining"'}),"):"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'outputA()\n  .then((data) => {\n    console.log(data); // output the result of "outputA()" to the console\n    return outputB();\n  })\n  .then((data) => {\n    console.log(data); // output the result of "outputB()" to the console\n    return outputC();\n  })\n  .then((data) => {\n    console.log(data); // output the result of "outputC()" to the console\n  })\n  .catch((err) => {\n    console.log(err); // output the error to the console\n  });\n'})}),"\n",(0,s.jsxs)(t.p,{children:['Success! We always have "A", followed by "B" and "C" in the console and the errors are correctly handled when they occur (preventing the subsequent promises from executing). We have the benefit of not having to ',(0,s.jsx)(t.em,{children:"alter"}),' the functions themselves at all if follow-up logic is necessary. Each function simply does its job, then reports back with the data ("resolves") if it was successful or sends the error ("rejects") it failed. This is a much more maintainable, scalable and cleaner approach to working with asynchronous code. This is why you will find that most modules mentioned in these notes are "promise-based", ie: if their logic is asynchronous, functions provided by the module will return ',(0,s.jsx)(t.strong,{children:"Promise"})," objects."]}),"\n",(0,s.jsxs)(t.p,{children:["While functions that return promises are indeed the preferred way to work with asynchronous operations in JavaScript, as you can see from the above code, ",(0,s.jsx)(t.em,{children:"working"}),' with promises can sometimes be difficult. If we wish to chain promises (in the case above) We must ensure that for every "then()" callback function returns the correct follow up function and it can be difficult to visually walk through the code.']}),"\n",(0,s.jsx)(t.h2,{id:"async--await",children:"Async & Await"}),"\n",(0,s.jsxs)(t.p,{children:["To help us work with promises more easily in JavaScript, ECMAScript 2016 (ES7) released ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",children:"async"})," & ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await",children:"await"}),' as an alternative to using "then()" and "catch()"']}),"\n",(0,s.jsx)(t.h3,{id:"putting-it-together-again",children:"Putting it Together (again)"}),"\n",(0,s.jsxs)(t.p,{children:['Knowing that there is an alternative to "then()" and "catch()", let\'s see how we can re-write the section of "Putting it Together" that ',(0,s.jsx)(t.em,{children:"makes use of"})," the promises (we will ",(0,s.jsx)(t.em,{children:"not"}),' alter the functions themselves) using "async" and "await". To achieve this, we must place our logic inside a function, ie "showOutput()" - the reason for this will be described below:']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'async function showOutput() {\n  try {\n    let A = await outputA();\n    console.log(A); // output the result of "outputA()" to the console\n\n    let B = await outputB();\n    console.log(B); // output the result of "outputB()" to the console\n\n    let C = await outputC();\n    console.log(C); // output the result of "outputC()" to the console\n  } catch (err) {\n    console.log(err); // output the error for outputA(), outputB() or outputC() to the console\n  }\n}\n\nshowOutput();\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This is ",(0,s.jsx)(t.em,{children:"much"}),' cleaner and easier to read. By using the "await" operator, we\'re essentially saying "wait for this function\'s returned promise to resolve". Additionally, you can see that we actually get the resolved value from the promise!']}),"\n",(0,s.jsx)(t.h3,{id:"using-await",children:"Using Await"}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:'"await" pauses the execution of its surrounding async function until the promise is settled (that is, fulfilled or rejected). When execution resumes, the value of the await expression becomes that of the fulfilled promise.'}),"\n",(0,s.jsx)(t.p,{children:"If the promise is rejected, the await expression throws the rejected value."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await",children:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await"})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:['Notice how the documentation mentions the "surrounding async function". This is because to actually ',(0,s.jsx)(t.strong,{children:"use"}),' the "await" operator, it ',(0,s.jsx)(t.strong,{children:"must"}),' be placed within a function marked as "async". If we fail to do this and try to use await outside of an async function, we will get an error:']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"SyntaxError: await is only valid in async functions and the top level bodies of modules\n"})}),"\n",(0,s.jsxs)(t.p,{children:['You will also notice how the documentation mentions that if the promise is rejected, the await expression "throws the rejected value". This is why we must place our "await" logic within a "try" / "catch" block. If we fail to do so and one of the promise-based functions is actually rejected, we will get the following error (',(0,s.jsx)(t.strong,{children:"NOTE:"}),' this error also occurs if a ".catch()" function is missing when using then() & catch()):']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch().\n"})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"NOTE"}),': When using "async" to identify a function, you are implicitly ',(0,s.jsx)(t.strong,{children:"returning a Promise"}),". This is because async functions ",(0,s.jsx)(t.em,{children:"cannot"}),' exist within the normal flow of execution (since they contain asynchronous code). If you do return a value from an "async" function, it will be the "resolved" value of the returned promise:']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"async function adder(num1, num2) {\n  return num1 + num2;\n}\n\nadder(1, 2).then((result) => console.log(result)); //3\n"})}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var o=n(6540);const s={},a=o.createContext(s);function i(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);