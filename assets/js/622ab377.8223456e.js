"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[9567],{1998:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Web-Server-Introduction/simple-web-server-using-expressjs","title":"Simple Web Server using Express.js","description":"Simple Web Server using Express.js","source":"@site/docs/Web-Server-Introduction/simple-web-server-using-expressjs.md","sourceDirName":"Web-Server-Introduction","slug":"/Web-Server-Introduction/simple-web-server-using-expressjs","permalink":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/simple-web-server-using-expressjs","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/Web-Server-Introduction/simple-web-server-using-expressjs.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"simple-web-server-using-expressjs","title":"Simple Web Server using Express.js","sidebar_position":3,"description":"Simple Web Server using Express.js"},"sidebar":"courseNotesSidebar","previous":{"title":"Modules & Node Package Manager","permalink":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/modules-node-package-manager"},"next":{"title":"Example Code","permalink":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/example-code"}}');var r=n(4848),i=n(8453);const o={id:"simple-web-server-using-expressjs",title:"Simple Web Server using Express.js",sidebar_position:3,description:"Simple Web Server using Express.js"},a="Simple Web Server using Express.js",l={},c=[{value:"Project Structure",id:"project-structure",level:2},{value:"Express.js",id:"expressjs",level:2},{value:"Simple &#39;GET&#39; Routes",id:"simple-get-routes",level:3},{value:"Returning .html Files",id:"returning-html-files",level:3},{value:"CSS &amp; Images",id:"css--images",level:3},{value:"Public Hosting (Vercel)",id:"public-hosting-vercel",level:2}];function h(e){const s={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"simple-web-server-using-expressjs",children:"Simple Web Server using Express.js"})}),"\n",(0,r.jsxs)(s.p,{children:["A major focus of these notes going forward will be creating modern web applications using Node.js. While are many ways of accomplishing this task, including using the built-in ",(0,r.jsx)(s.a,{href:"https://nodejs.org/docs/latest/api/http.html",children:"'http' module"}),", we will be using the extremely popular ",(0,r.jsx)(s.a,{href:"https://expressjs.com",children:'"Express"'})," web framework, ",(0,r.jsx)(s.a,{href:"https://www.npmjs.com/package/express",children:"available on NPM"}),"."]}),"\n",(0,r.jsx)(s.h2,{id:"project-structure",children:"Project Structure"}),"\n",(0,r.jsx)(s.p,{children:'To get started working with Node.js and Express, we should create a new folder for our application (ie: "MyServer", as used in the below example). Once this is completed, open it in Visual Studio Code and create the following directory structure by adding "public" and "views" folders as well as a "server.js" file:'}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"/MyServer\n  \u21aa /public\n  \u21aa /views\n  \u21aa server.js\n"})}),"\n",(0,r.jsxs)(s.p,{children:['Next, we must open the integrated terminal and create the all-important "package.json" file at the root of our "MyServer" folder, using the command ',(0,r.jsx)(s.strong,{children:'"npm init"'}),"."]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," You will be using all of the ",(0,r.jsx)(s.em,{children:"default"})," options when creating your package.json file"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Once this is complete, you should have a new package.json file in your MyServer folder that looks like the following:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-json",children:'{\n  "name": "myserver",\n  "version": "1.0.0",\n  "description": "",\n  "main": "server.js",\n  "scripts": {\n    "test": "echo \\"Error: no test specified\\" && exit 1",\n    "start": "node server.js"\n  },\n  "author": "",\n  "license": "ISC"\n}\n'})}),"\n",(0,r.jsx)(s.h2,{id:"expressjs",children:"Express.js"}),"\n",(0,r.jsx)(s.p,{children:"Express.js is described as:"}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsx)(s.p,{children:'"a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications."'}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Essentially, it is a Node module that takes a lot of the leg work out of creating a framework to build a website. It is extremely popular in the node.js community with a multitude of developers using it to build websites. It is a proven way to build flexible web applications quickly and easily."}),"\n",(0,r.jsx)(s.p,{children:'To use it in our project we need to use "npm" to install it. From the integrated terminal in Visual Studio code, enter the command:'}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"npm i express\n"})}),"\n",(0,r.jsx)(s.p,{children:'(where "i" is shorthand for the "install" command).'}),"\n",(0,r.jsxs)(s.p,{children:['Once this is complete, you should see that your "package.json" file has a new entry that looks like the following (',(0,r.jsx)(s.strong,{children:"NOTE:"})," Your version may differ from the below):"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-json",children:'"dependencies": {\n    "express": "^4.18.2"\n  }\n'})}),"\n",(0,r.jsxs)(s.p,{children:["You will also notice that a 2",(0,r.jsx)("sup",{children:"nd"}),' file was created called "package-lock.json":']}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsx)(s.p,{children:"The purpose of package-lock.json is to ensure that the same dependencies are installed consistently across different environments, such as development and production environments. It also helps to prevent issues with installing different package versions, which can lead to conflicts and errors."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"https://www.atatus.com/blog/package-json-vs-package-lock-json/#package-lock-json",children:"https://www.atatus.com/blog/package-json-vs-package-lock-json/#package-lock-json"})}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:'Finally, we also now have the aforementioned "node_modules" folder, which not only contains an "express" folder, but also folders for all of the other modules that "express" depends upon, such as "cookie", "encodeurl", "http-errors", etc.'}),"\n",(0,r.jsxs)(s.p,{children:['To begin using Express.js, we must first "require" it in our server.js file and execute the code to start our server. As a starting point, you may use the following ',(0,r.jsx)(s.em,{children:"boilerplate"})," code:"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"File: server.js"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:'const express = require(\'express\'); // "require" the Express module\nconst app = express(); // obtain the "app" object\nconst HTTP_PORT = process.env.PORT || 8080; // assign a port\n\n// start the server on the port and output a confirmation to the console\napp.listen(HTTP_PORT, () => console.log(`server listening on: ${HTTP_PORT}`));\n'})}),"\n",(0,r.jsxs)(s.p,{children:['The above code will be used in nearly every server written using "Express" in these notes. As mentioned above, it "requires" the Express module, which is then invoked as a function to get an "app" object, which is used to start our server on a given HTTP Port. The reason that the HTTP_PORT constant is defined as ',(0,r.jsx)(s.code,{children:"process.env.PORT || 8080"}),' is because when we move our server online, it will be assigned a different port, using a "PORT" environment variable.']}),"\n",(0,r.jsx)(s.p,{children:'If we now want to start our server, we can simply execute the "server.js" file using node:'}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"node --watch server.js\n"})}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"}),' the "--watch" flag will cause Node to run in "watch" mode, which will restart the process when a change is detected']}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["If you open a browser to: ",(0,r.jsx)(s.code,{children:"http://localhost:8080"}),", you should see the following message:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"Cannot GET /\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Congratulations!"}),' Your web server is up and running! Unfortunately, we don\'t have any "routes" (ie: paths to pages / resources) defined yet, so the Express framework automatically generated a ',(0,r.jsx)(s.strong,{children:"404"})," error for the path that we tried to access (ie: GET /)"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," To stop the server from running, you may use the ",(0,r.jsx)(s.code,{children:"Ctrl+C"})," command from the integrated terminal in Visual Studio Code"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"simple-get-routes",children:"Simple 'GET' Routes"}),"\n",(0,r.jsxs)(s.p,{children:['As you have seen from running our server, not much is happening. Even if we try to navigate around to other paths such as "',(0,r.jsx)(s.a,{href:"http://localhost:8080/about",children:"http://localhost:8080/about"}),'" (thereby making a "GET" request to the "/about" path (route)), we will keep getting the same 404 error: "Cannot GET". This is because we have not defined any "GET" routes within our server.']}),"\n",(0,r.jsxs)(s.p,{children:["To fix this, we must write code in our server.js file to correctly ",(0,r.jsx)(s.em,{children:"respond"})," to these types of requests. This can be accomplished using the ",(0,r.jsx)(s.a,{href:"https://expressjs.com/en/api.html#app",children:'"app"'}),' object, that was used to start our server. If we wish to respond to a "GET" request, we must invoke a "GET" function and provide the target path as well as a "callback" function to handle the request. For example, if we wish to respond to a "GET" request on the "/" route, we would write the following code ',(0,r.jsx)(s.em,{children:"before"})," the call to app.listen();"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:"app.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n"})}),"\n",(0,r.jsx)(s.p,{children:'Here, we have specified a callback function to be executed when our server encounters a "GET" request for the "/" route. It will be invoked with the following parameters:'}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"https://expressjs.com/en/api.html#req",children:'"req"'}),': The "request" object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on.']}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"https://expressjs.com/en/api.html#res",children:'"res"'}),': "The "response" object represents the HTTP response that an Express app sends when it gets an HTTP request']}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:['In the above case, we use the "res" object\'s ',(0,r.jsx)(s.a,{href:"https://expressjs.com/en/api.html#res.send",children:'"send"'})," method to send a response back to the client."]}),"\n",(0,r.jsxs)(s.p,{children:["If we wish to have a second route, all we have to do is add another call to ",(0,r.jsx)(s.a,{href:"https://expressjs.com/en/api.html#app.get.method",children:'"app.get()"'}),' with the new path. This is how we will define any path "route" that we wish our server to respond to, when it encounters a "GET" request from a web client (ie: web browser):']}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:"app.get('/about', (req, res) => {\n  res.send('About the Company');\n});\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Now, we should be able to navigate to both: ",(0,r.jsx)(s.code,{children:"http://localhost:8080"})," and ",(0,r.jsx)(s.code,{children:"http://localhost:8080/about"})," and see the text sent by our server."]}),"\n",(0,r.jsx)(s.h3,{id:"returning-html-files",children:"Returning .html Files"}),"\n",(0,r.jsx)(s.p,{children:'Returning plain text is fine to test if our routes are configured properly, however if we want to start making web applications, we should be returning valid HTML documents. To get started, we will create two simple .html files within the "views" folder:'}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"File: /MyServer/views/home.html"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Home</title>\n  </head>\n  <body>\n    <h1>Welcome Home</h1>\n    <p>...</p>\n    <p><a href="/about">About the Company</a></p>\n  </body>\n</html>\n'})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"File: /MyServer/views/about.html"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>About</title>\n  </head>\n  <body>\n    <h1>About the Company</h1>\n    <p>...</p>\n    <p><a href="/">Back Home</a></p>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(s.p,{children:["Next, we must update our route definitions to return these documents ",(0,r.jsx)(s.em,{children:"instead"}),' of the simple messages: "Hello World!" and "About the Company". To achieve this, we will be using the ',(0,r.jsx)(s.a,{href:"https://expressjs.com/en/api.html#res.sendFile",children:'"sendFile()"'}),' method of the "res" object, ',(0,r.jsx)(s.em,{children:"instead"}),' of "send()".']}),"\n",(0,r.jsxs)(s.p,{children:['For "sendFile()" to function correctly, we must provide an ',(0,r.jsx)(s.strong,{children:"absolute"})," path to the file we wish to send as a parameter to the function. As you know, we cannot hard-code this path into our server.js, as this path will differ depending on which machine is executing the code - for example: the service the app is deployed on, vs. your local computer."]}),"\n",(0,r.jsx)(s.p,{children:'This is where knowledge of the built-in "path" module and the __dirname global come into play.'}),"\n",(0,r.jsxs)(s.p,{children:["At the top of your server file, we will ",(0,r.jsx)(s.em,{children:"require"}),' "path";']}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:"const path = require('path');\n"})}),"\n",(0,r.jsx)(s.p,{children:'Next, we can update our routes to use "sendFile()" as follows:'}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:"res.sendFile(path.join(__dirname, '/views/someFile.html'));\n"})}),"\n",(0,r.jsxs)(s.p,{children:["where ",(0,r.jsx)(s.strong,{children:'"someFile.html"'}),' would be any file that you wish to send back to the client, from your "views" folder, ie: "home.html" or "about.html". We use ',(0,r.jsx)(s.code,{children:"path.join()"}),' to safely join the "__dirname" path with the local path to the file. Together, this results in an absolute path that is ',(0,r.jsx)(s.em,{children:"not"})," tied to a specific machine."]}),"\n",(0,r.jsx)(s.h3,{id:"css--images",children:"CSS & Images"}),"\n",(0,r.jsxs)(s.p,{children:['Now that we know how to send complete HTML files back to the client, the next step is including "static" resources, ie: images, CSS, etc. So far, if we wish to respond to a request from a client we must have an explicit "route" configured. For example, the "/about" route only works because we have defined the corresponding ',(0,r.jsx)(s.code,{children:'app.get("/about", ...)'})," function call. What happens when a request for a static resources is requested? Do we have to have a specific root configured for every resource? Thankfully, the answer is ",(0,r.jsx)(s.em,{children:"no"}),"."]}),"\n",(0,r.jsx)(s.p,{children:'Using Express, we can identify a specific folder as "static" and any valid requests for resources contained within that folder are automatically sent back to the client with a 200 status code.'}),"\n",(0,r.jsx)(s.p,{children:'Using our existing project structure, we can use the "public" folder as our static folder and place any static resources in there. For example, if we want a custom CSS file, we could place it in:'}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"/MyServer\n  \u21aa /public\n    \u21aa /css\n      \u21aa site.css\n"})}),"\n",(0,r.jsx)(s.p,{children:"We could then link to it in our HTML documents the code:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-html",children:'<link rel="stylesheet" href="/css/site.css" />\n'})}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," The same pattern would work for images as well, ie:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"/MyServer\n  \u21aa /public\n    \u21aa /img\n      \u21aa banner.jpg\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-html",children:'<img src="/img/banner.jpg" alt="site banner" />\n'})}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:['Notice how we do not include "/public" in the ',(0,r.jsx)(s.code,{children:"href"})," (or ",(0,r.jsx)(s.code,{children:"src"}),') properties. This is because we will mark "/public" as the official "static" folder and all requests must made to resources ',(0,r.jsx)(s.em,{children:"within"})," the folder. To accomplish this in our server.js file, we can add the following code ",(0,r.jsx)(s.em,{children:"above"})," the other ",(0,r.jsx)(s.code,{children:"app.get()"})," function calls:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:"app.use(express.static('public'));\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Here, we have used ",(0,r.jsx)(s.a,{href:"https://expressjs.com/en/api.html#express.static",children:'"express.static()"'})," - a built-in ",(0,r.jsx)(s.a,{href:"https://expressjs.com/en/guide/using-middleware.html#middleware.application",children:"middleware"}),' function (explained later in these notes) to mark the "public" directory as static. With this code in place, whenever a request is sent to our server, Express will first check to see if the requested resource exists in the "public" folder, before checking our other routes.']}),"\n",(0,r.jsx)(s.h2,{id:"public-hosting-vercel",children:"Public Hosting (Vercel)"}),"\n",(0,r.jsxs)(s.p,{children:["As a final exercise, review the documentation on ",(0,r.jsx)(s.a,{href:"/Resources/vercel-guide",children:'"Getting Started with Vercel"'})," and see if you can get the server running online!"]})]})}function d(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>a});var t=n(6540);const r={},i=t.createContext(r);function o(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);