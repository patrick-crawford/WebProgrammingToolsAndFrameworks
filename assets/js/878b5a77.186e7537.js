"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[1570],{5174:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"Handling-Asynchronous-Code/callbacks","title":"Callbacks","description":"Callbacks","source":"@site/docs/Handling-Asynchronous-Code/callbacks.md","sourceDirName":"Handling-Asynchronous-Code","slug":"/Handling-Asynchronous-Code/callbacks","permalink":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/callbacks","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/Handling-Asynchronous-Code/callbacks.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"callbacks","title":"Callbacks","sidebar_position":1,"description":"Callbacks"},"sidebar":"courseNotesSidebar","previous":{"title":"Example Code","permalink":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/example-code"},"next":{"title":"Promises & Async / Await","permalink":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/promises-async-await"}}');var a=t(4848),s=t(8453);const i={id:"callbacks",title:"Callbacks",sidebar_position:1,description:"Callbacks"},r="Callbacks",c={},l=[{value:"Defining Functions with Callbacks",id:"defining-functions-with-callbacks",level:2},{value:"Adding Parameters",id:"adding-parameters",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"callbacks",children:"Callbacks"})}),"\n",(0,a.jsx)(n.p,{children:'Before we begin to discuss "callbacks" and other methods for working with asynchronous logic within our programs, we should first define what "asynchronous programming" is:'}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:'"Asynchronous programming is a technique that enables your program to start a potentially long-running task and still be able to be responsive to other events while that task runs, rather than having to wait until that task has finished. Once that task has finished, your program is presented with the result."'}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing",children:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This means that potentially long-running tasks will not cause delays within our main execution logic. However, it also means that we need to find a way to execute code when a long-running task has completed (ie: connecting to a database, reading a file, etc)."}),"\n",(0,a.jsxs)(n.p,{children:["As a simple example of how JavaScript works with asynchronous code, we can refer back to our ",(0,a.jsx)(n.a,{href:"/Introduction/hello-world#settimeout",children:'"setTimeout"'})," example; only this time we will wait 2 seconds (2000 milliseconds) and execute some code ",(0,a.jsx)(n.em,{children:"before"})," and ",(0,a.jsx)(n.em,{children:"after"})," the function:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"console.log('Hello');\n\nsetTimeout(() => {\n  console.log('World');\n}, 2000);\n\nconsole.log('!');\n"})}),"\n",(0,a.jsxs)(n.p,{children:['Here, we see the text output to the console is out of order, ie: "Hello" followed by "!" and (2 seconds later) we finally see the text "World". This is because the "setTimeout" function is "asynchronous" and will not cause the main flow of execution to wait (2 seconds) for it to complete. The ',(0,a.jsx)(n.em,{children:"function"}),' that is passed in the first parameter of "setTimeout" (which is responsible for outputting "World" to the console) is a ',(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Callback_function",children:(0,a.jsx)(n.strong,{children:"callback"})})," function:"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:'"a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action."'}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"defining-functions-with-callbacks",children:"Defining Functions with Callbacks"}),"\n",(0,a.jsxs)(n.p,{children:["Now that we know that a callback is really just a function passed to another function to perform an action once some asynchronous logic is complete, let's try writing our own code. Here, we will be using the ",(0,a.jsx)(n.a,{href:"https://nodejs.org/docs/latest/api/timers.html#settimeoutcallback-delay-args",children:"setTimeout()"})," function to approximate an asynchronous action such as connecting to a database."]}),"\n",(0,a.jsx)(n.p,{children:'For our first example, let\'s say that we have a function called "connectToDatabase" that establishes a database connection after a random amount of time (between 1 and 2000 milliseconds). We also have a function called "queryData" that also takes a random amount of time to complete (in this case, it is between 1 and 1000 milliseconds).'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function connectToDatabase() {\n  let randomTime = Math.floor(Math.random() * 2000) + 1;\n\n  setTimeout(() => {\n    console.log('Connection Established');\n  }, randomTime);\n}\n\nfunction queryData() {\n  let randomTime = Math.floor(Math.random() * 1000) + 1;\n\n  setTimeout(() => {\n    console.log('Query Complete');\n  }, randomTime);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"For our code to work correctly, we must first connect to the database, then query the data. To accomplish this, we would intuitively write the code to invoke the functions in order, ie:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"connectToDatabase();\nqueryData();\n"})}),"\n",(0,a.jsxs)(n.p,{children:["However, this poses a problem as there's no way to ensure that the logic to connect to the database happens ",(0,a.jsx)(n.strong,{children:"before"})," the query. In fact, since it takes longer to connect to the database, it's more likely that the query logic will complete first."]}),"\n",(0,a.jsxs)(n.p,{children:['One way to solve this problem is to provide the "queryData()" function as a ',(0,a.jsx)(n.strong,{children:"callback"}),' function to "connectToDatabase()" to be executed once the connection has been established:']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function connectToDatabase(queryFunction) {\n  let randomTime = Math.floor(Math.random() * 2000) + 1;\n\n  setTimeout(() => {\n    console.log('Connection Established');\n    queryFunction();\n  }, randomTime);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:'Notice how we have added "queryFunction" as a parameter to the connectToDatabase() function. Once the connection has been established, we manually invoke the function using "()".'}),"\n",(0,a.jsx)(n.p,{children:"Now, we can ensure that the functions are executed in order, using the code:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"connectToDatabase(queryData);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"adding-parameters",children:"Adding Parameters"}),"\n",(0,a.jsx)(n.p,{children:'As our code stands now, the "queryData" function is very simple and does not take any parameters. Why don\'t we try making it a little more dynamic by adding parameters to it, so that a query can be provided:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function queryData(query) {\n  let randomTime = Math.floor(Math.random() * 1000) + 1;\n\n  setTimeout(() => {\n    console.log(query);\n  }, randomTime);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now we can invoke our queryData with a given query, for example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"queryData('select * from Employees');\n"})}),"\n",(0,a.jsxs)(n.p,{children:['However, a problem occurs when we attempt to provide the "queryData" function as a ',(0,a.jsx)(n.strong,{children:"callback"}),' to another function (in our case, the "connectToDatabase" function):']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"connectToDatabase(queryData('select * from Employees')); // TypeError: queryFunction is not a function\n"})}),"\n",(0,a.jsxs)(n.p,{children:['This is because the "()" syntax after the function name causes the function to ',(0,a.jsx)(n.em,{children:"execute"}),' which then passes its return value ("undefined") to the connectToDatabase function. To solve this, we must pass the parameters to the "queryData()" callback function, as parameters to the "connectToDatabase()" function:']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function connectToDatabase(queryFunction, query) {\n  let randomTime = Math.floor(Math.random() * 2000) + 1;\n\n  setTimeout(() => {\n    console.log('Connection Established');\n    queryFunction(query);\n  }, randomTime);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:'Here, you can see that we have added the "query" as a 2nd parameter to the connectToDatabase function and use it as a parameter to the "queryFunction".'}),"\n",(0,a.jsx)(n.p,{children:"Putting it all together, we get:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function connectToDatabase(queryFunction, query) {\n  let randomTime = Math.floor(Math.random() * 2000) + 1;\n\n  setTimeout(() => {\n    console.log('Connection Established');\n    queryFunction(query);\n  }, randomTime);\n}\n\nfunction queryData(query) {\n  let randomTime = Math.floor(Math.random() * 1000) + 1;\n\n  setTimeout(() => {\n    console.log(query);\n  }, randomTime);\n}\n\nconnectToDatabase(queryData, 'select * from Employees');\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var o=t(6540);const a={},s=o.createContext(a);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);