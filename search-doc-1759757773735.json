{"searchDocs":[{"title":"Application, Request & Response Objects","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects","content":"","keywords":"","version":"Next"},{"title":"The Application object​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#the-application-object","content":" The &quot;app&quot; object in the example above represents the express main application object. It contains several methods for tasks, such as processing route requests, setting up middleware, and managing html views or view engines.  In the above example, we set a route on the host to handle HTTP GET requests to “/”. This means any &quot;GET&quot; requests to localhost:8080/ will be sent to this function. A typical route handler in express (like the one above) is created by invoking a function on the app object using the HTTP method (verb) that matches the type of request and passing it two parameters: a string representing the route, and a callback function to invoke when the route is matched. In this case, we wish to handle GET requests for the default route &quot;/&quot; (typically requests from the browser to load the page initially).  Here are some of the commonly used application properties and methods that we will use throughout these notes.  ","version":"Next","tagName":"h2"},{"title":"app.all()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#appall","content":" This method is used to register a single callback for a route that matches any HTTP Method IE: GET, PUT, POST, DELETE, etc.  app.all('/http-testing', (req, res) =&gt; { res.send('test complete'); });   ","version":"Next","tagName":"h3"},{"title":"HTTP Verb Methods​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#http-verb-methods","content":" We can also respond to a request a callback for a route using a single HTTP Method (ie: app.get() from our Simple Web Server using Express.js example):  app.get('/get-test', (req, res) =&gt; { res.send('GET Test Complete'); }); app.put('/put-test', (req, res) =&gt; { res.send('PUT Test Complete'); }); app.post('/post-test', (req, res) =&gt; { res.send('POST Test Complete'); }); app.delete('/delete-test', (req, res) =&gt; { res.send('DELETE Test Complete'); }); // etc.   ","version":"Next","tagName":"h3"},{"title":"app.locals​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#applocals","content":" The &quot;locals&quot; property allows you to attach local variables to the application, which persist throughout the life of the app. You can access local variables in templates rendered within the application (discussed in &quot;Template Engines&quot;).  app.locals.title = 'My App';   ","version":"Next","tagName":"h3"},{"title":"app.listen()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#applisten","content":" As we have seen, this function is used to start the HTTP server listening for connections on a specific port, ie:  const HTTP_PORT = process.env.PORT || 8080; // (route handlers / middleware) ... app.listen(HTTP_PORT, () =&gt; { console.log('server listening on: ' + HTTP_PORT); });   ","version":"Next","tagName":"h3"},{"title":"app.set()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#appset","content":" The &quot;set&quot; method assigns a value to a specific &quot;setting&quot;. According to the documentation, you may store any value that you want in your own custom &quot;setting&quot;, however certain settings can be used to configure the behavior of the server. For example, we will be setting the value of the &quot;view engine&quot; setting when configuring our template engine.  ","version":"Next","tagName":"h3"},{"title":"app.use()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#appuse","content":" The use method is used to add middleware to your application. Middleware consists of functions (typically placed before the route handlers) that automatically execute either when a specified path is matched or globally before every request. This is very useful when you want to do something with every request like add properties to the request object or check if a user is logged in.  This is discussed further in the next section: &quot;Middleware&quot;  ","version":"Next","tagName":"h3"},{"title":"The Request object​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#the-request-object","content":" The &quot;req&quot; object represents the object that contains all the information and metadata for the request sent to the server. When you see examples of the request object in use, it will typically be referred to as ‘req’ (short for request object).  Some of the commonly used request properties and methods used throughout these notes are:  ","version":"Next","tagName":"h2"},{"title":"req.body​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#reqbody","content":" The req.body property contains the data submitted as part of request. It requires that you use a &quot;body parsing&quot; middleware (discussed in: &quot;Middleware&quot;) which will attach data (properties) to req.body. If you post data in your request, this is how you access that data.  app.post('/urlencoded-test', (req, res) =&gt; { res.send(req.body); });   ","version":"Next","tagName":"h3"},{"title":"req.cookies​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#reqcookies","content":" If we wish to read the value specific &quot;cookie&quot; value, ie:  &quot;a small piece of data that a server sends to a user's web browser. The browser may store the cookie and send it back to the same server with later requests.&quot; https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies  we can reference it using the corresponding property on the &quot;req.cookies&quot; object:  // Cookie: name=tj console.log(req.cookies.name); // &quot;tj&quot;   However, like &quot;req.body&quot; above, we must use a (&quot;cookie parsing&quot;) middleware function to populate &quot;req.cookies&quot; with data from the cookie  ","version":"Next","tagName":"h3"},{"title":"req.params​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#reqparams","content":" The &quot;params&quot; property is used when we wish to read the values of &quot;Route Parameters&quot; defined in our route handlers:  &quot;Route parameters are named URL segments used to capture values at specific positions in the URL. The named segments are prefixed with a colon and then the name (E.g., /:your_parameter_name/).&quot; https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes#route_parameters  For example, if we wish to match all GET requests for the route &quot;/employee/employeeNum&quot;, where employeeNum can be any value, ie: &quot;123&quot;, &quot;abc456&quot;, etc, we can use the following code:  app.get('/employee/:employeeNum', (req, res) =&gt; { res.send(`Employee Number: ${req.params.employeeNum}`); });   ","version":"Next","tagName":"h3"},{"title":"req.query​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#reqquery","content":" The &quot;query&quot; property is needed when we wish to read the values of the &quot;query string&quot; in the url:  A query string is a part of a uniform resource locator (URL) that assigns values to specified parameters. A query string commonly includes fields added to a base URL by a Web browser or other client application, for example as part of an HTML document, choosing the appearance of a page, or jumping to positions in multimedia content A typical URL containing a query string is as follows: https://example.com/over/there?name=ferret https://en.wikipedia.org/wiki/Query_string  For example, if we wanted to match a GET request for the route &quot;/products&quot; that also supports the optional query string value &quot;onsale&quot;, ie: &quot;/products?onsale=true&quot;, we could use the code:  app.get('/products', (req, res) =&gt; { let result = 'all Products'; // NOTE: query parameter values are always strings if (req.query.onsale == 'true') { result += ' (on sale)'; } res.send(result); });   When designing route handlers that can accept query string values, we do not include them in the &quot;route&quot; (ie: &quot;/products&quot;). Additionally, since the route will match without the &quot;onSale&quot; query sting value, it is important to return a value if it's missing (ie: &quot;all Products&quot; or an error if the query parameter must be present)  info Multiple query parameters may also be used, and are separated by an ampersand, &quot;&amp;&quot;: https://example.com/path/to/page?name=ferret&amp;color=purple  ","version":"Next","tagName":"h3"},{"title":"req.get()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#reqget","content":" req.get() is necessary for checking the values of specific HTTP headers sent with the request. For example:  app.get('/hello', (req, res) =&gt; { res.send(`Hello ${req.get('user-agent')}`); });   Here, when a user requests the &quot;/hello&quot; route, they should see the text &quot;Hello&quot; followed by the content of the &quot;user-agent&quot; header sent with the request.  ","version":"Next","tagName":"h3"},{"title":"The Response object​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#the-response-object","content":" The &quot;res&quot; object represents the object that contains all the information and metadata for a response sent from the server. When you see examples of the response object in use it will typically be referred to as ‘res’ (short for response object). The data you send back from the server can be one of several different formats - the most common of which are HTML, JSON, CSS, JS and plain files (.pdf, .txt, .jpg, .png, etc).  Some of the commonly used response properties and methods used throughout these notes are:  ","version":"Next","tagName":"h2"},{"title":"res.cookie()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#rescookie","content":" This allows you to send a cookie with the response, specified using a name = value key pair. You can set the value to a string / object using JSON notation and it will be included in the &quot;Set-Cookie&quot; header of the response. For example:  app.get('/cookie-test', (req, res) =&gt; { res.cookie('message', 'Hello World!'); res.send('Cookie Sent!'); });   ","version":"Next","tagName":"h3"},{"title":"res.set()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#resset","content":" res.set() enables you to set the values of specific / custom HTTP headers sent with the request. For example:  app.get('/custom', (req, res) =&gt; { res.set('Custom-Header', 'MyValue'); res.send(`Custom-Header Sent`); });   ","version":"Next","tagName":"h3"},{"title":"res.end()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#resend","content":" res.end() is used you want to end a response immediately and send nothing back. For example, we may wish to send a &quot;204 - No Content&quot; status code, which indicates that &quot;a request has succeeded, but that the client doesn't need to navigate away from its current page&quot;. For example:  app.put('/update', (req, res) =&gt; { // ... (update logic) res.status(204).end(); });   ","version":"Next","tagName":"h3"},{"title":"res.redirect()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#resredirect","content":" The res.redirect() method is used to perform a redirect to another page on your site, go back to the previous page, or redirect to another domain. For example:  app.get('/to-google', (req, res) =&gt; { res.redirect('https://www.google.ca/'); });   ","version":"Next","tagName":"h3"},{"title":"res.send()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#ressend","content":" This is the primary response method to send a response to the client. You can send a String, Object, Array, or even a Buffer object back to the client. The send() method will automatically set the Content-Type header for you based on the type of data sent. For example:  app.get('/json-test', (req, res) =&gt; { res.send({ message: 'Hello World!' }); // Content-Type: application/json; charset=utf-8 }); app.get('/plain-text-test', (req, res) =&gt; { res.send('Hello World!'); // Content-Type: text/html; charset=utf-8 });   info When sending a JavaScript object back (as in the example above), the &quot;send()&quot; method will internally convert it to a JSON-formatted string  ","version":"Next","tagName":"h3"},{"title":"res.sendFile()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#ressendfile","content":" As we have seen, this function is used when we wish to send a file (typically .html) back to the client. We use path.join() to safely join __dirname with the path of the file to be sent. This function also correctly sets the Content-Type response HTTP header based on the file extension. For example:  app.get('/', (req, res) =&gt; { res.sendFile(path.join(__dirname, '/views/home.html')); });   ","version":"Next","tagName":"h3"},{"title":"res.status()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/application-request-response-objects#resstatus","content":" res.status() is used to set a specific status code for the response (as seen above in the res.end() example). This will be useful when handling client / server errors and setting 4xx / 5xx series error codes. More detail is discussed in the following &quot;Middleware&quot; section. ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/example-code","content":"Example Code You may download the sample code for this topic here: Advanced-Routing-Middleware","keywords":"","version":"Next"},{"title":"Middleware","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/middleware","content":"","keywords":"","version":"Next"},{"title":"Getting Started​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/middleware#getting-started","content":" To implement middleware in our servers, we will begin by writing a simple middleware function that logs every request to the console. This function will be placed before any of our route handlers, ensuring that it gets executed for every request:  app.use((req, res, next) =&gt; { console.log(`Request from: ${req.get('user-agent')} [${new Date()}]`); next(); });   Notice how we make use of the aforementioned app.use() method to implement our middleware function. It looks very similar to a regular route handler, except it accepts a third parameter: next and (in this case) does not return anything to the client. It is because this function does not return anything to the client (ie: generate a &quot;response&quot;), that we must use the &quot;next()&quot; function - it simply calls the next middleware function, such as a route handler, ie:  app.get('/', (req, res) =&gt; { res.send('Hello World'); });   caution If we fail to invoke the next() function or return a response, our server will hang and the client request will timeout.  ","version":"Next","tagName":"h2"},{"title":"Updating \"req\"​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/middleware#updating-req","content":" Let's continue the example by updating the &quot;req&quot; object in our middleware example to include a &quot;log&quot; property that simply stores the output of the log entry as a string. We can use this value in a subsequent route handler and send it back to the client, ie:  app.use((req, res, next) =&gt; { let loggedItem = `Request from: ${req.get('user-agent')} [${new Date()}]`; console.log(loggedItem); req.log = loggedItem; next(); }); app.get('/', (req, res) =&gt; { res.send(`Hello - ${req.log}`); });   ","version":"Next","tagName":"h3"},{"title":"Restricting Route Access​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/middleware#restricting-route-access","content":" Another common use for middleware is to restrict route access for a specific route. This can be be accomplished by placing your middleware function as a parameter to the route handling function that requires restricted access. For example:  function randomDeny(req, res, next) { let allowed = Math.floor(Math.random() * 2); // 0 or 1 if (allowed) { next(); } else { res.status(403).send('Access Denied'); } } app.get('/secure', randomDeny, (req, res) =&gt; { res.send('Welcome!'); });   Here, we have implemented our middleware function as &quot;randomDeny&quot;, which randomly generates either a 0 or 1. If a 1 is generated, the &quot;next()&quot; function is invoked, allowing the route to be processed as normal. However, if a 0 is generated, a response, including the 403 - Forbidden error code is generated, informing the user that they do not have access (we could also redirect them to a &quot;login&quot; or &quot;register&quot; page, etc).  To ensure that this middleware function only affects the &quot;/secure&quot; route, we place it as the second parameter before the callback function.  ","version":"Next","tagName":"h3"},{"title":"404 Errors​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/middleware#404-errors","content":" As a final example of how to implement middleware in our server.js code - let's create a custom &quot;404&quot; error to send to the client if it has requested an unknown route (ie: a route that we have not created a handler for):  // Other route handlers, middleware, etc ... app.use((req, res, next) =&gt; { res.status(404).send(&quot;404 - We're unable to find what you're looking for.&quot;); }); // app.listen()   Here, we have created a middleware function using the familiar &quot;use()&quot; function. However, the main difference is where it is placed, ie: below all of our other middleware functions / route handlers. By placing it in this way, we can ensure that it only gets executed if none of the other route handlers return a response to the client.  ","version":"Next","tagName":"h3"},{"title":"Types of Middleware​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/middleware#types-of-middleware","content":" Now that we have seen how middleware is typically implemented within an Express application, let's quickly review the 5 types of middleware available:  ","version":"Next","tagName":"h2"},{"title":"Application-Level Middleware​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/middleware#application-level-middleware","content":" Application-level middleware is bound to your entire application and can run when every request comes in or only when it matches a specified route.  In the examples above, we have implemented &quot;Application-level middleware&quot;.  ","version":"Next","tagName":"h3"},{"title":"Router-Level Middleware​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/middleware#router-level-middleware","content":" Router-level middleware works the same way as application middleware but is attached to a separate router instance. Essentially, instead of &quot;app.use()&quot;, a separate express.Router() instance is created and the middleware is applied to it, ie:  const userRouter = express.Router(); userRouter.use((req, res, next) =&gt; { console.log('userRouter Middleware!'); next(); });   For more information on express.Router(), see the official documentation in the official Express Routing documentation.  ","version":"Next","tagName":"h3"},{"title":"Error-Handling Middleware​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/middleware#error-handling-middleware","content":" Error-handling middleware is defined with 4 parameters in the callback function, ie: (err, req, res, next). We must specify all 4 parameters so that express can differentiate it from a regular middleware function. Error handling middleware is invoked either when a regular middleware function calls next(err) instead of next(), or when exceptions occur in your route handlers. Like our &quot;404&quot; example above, error handling middleware should be placed below your route handlers. For example:  app.get('/error-test', (req, res) =&gt; { throw new Error('Error Test'); }); app.use((err, req, res, next) =&gt; { res.status(500).send(`500 - ${err.message}`); });   ","version":"Next","tagName":"h3"},{"title":"Built-In Middleware​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/middleware#built-in-middleware","content":" There are three types of built-in middleware functions available for us to use:  express.static()​  This is what we used when sending &quot;static&quot; files (ie: &quot;css&quot; files, images, etc) in the &quot;CSS &amp; Images&quot; section of the &quot;Simple Web Server using Express.js&quot; notes, ie:  app.use(express.static('public'));   express.json()​  This is used to parse &quot;JSON&quot; formatted payloads, and make the result available on the &quot;req&quot; object. For example:  app.use(express.json()); app.post('/json-test', (req, res) =&gt; { res.send(req.body); });   express.urlencoded()​  This is nearly identical to &quot;express.json&quot;, except this is used to parse data from a web form using the default &quot;enctype&quot;, (ie: &quot;application/x-www-form-urlencoded&quot;).  app.use(express.urlencoded({ extended: true })); app.post('/urlencoded-test', (req, res) =&gt; { res.send(req.body); });   info The “extended” option utilizes the &quot;qs&quot; library which enables rich objects and arrays to be encoded into the URL-encoded format, allowing for a JSON-like experience with URL-encoded. For more information, please see the qs library.  ","version":"Next","tagName":"h3"},{"title":"Third-Party Middleware​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingToolsAndFrameworks/Advanced-Routing-Middleware/middleware#third-party-middleware","content":" Since Express 4.x, previously included middleware that did common things such as handle cookies, or handle file uploads, have been moved to individual third-party middleware packages.  For example, parsing cookies requires the installation of cookie-parser:  $ npm install cookie-parser   const cookieParser = require('cookie-parser'); // load the cookie-parsing middleware app.use(cookieParser());   For a list of supported, third party middleware, refer to the official documentation. ","version":"Next","tagName":"h3"},{"title":"Callbacks","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/callbacks","content":"","keywords":"","version":"Next"},{"title":"Defining Functions with Callbacks​","type":1,"pageTitle":"Callbacks","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/callbacks#defining-functions-with-callbacks","content":" Now that we know that a callback is really just a function passed to another function to perform an action once some asynchronous logic is complete, let's try writing our own code. Here, we will be using the setTimeout() function to approximate an asynchronous action such as connecting to a database.  For our first example, let's say that we have a function called &quot;connectToDatabase&quot; that establishes a database connection after a random amount of time (between 1 and 2000 milliseconds). We also have a function called &quot;queryData&quot; that also takes a random amount of time to complete (in this case, it is between 1 and 1000 milliseconds).  function connectToDatabase() { let randomTime = Math.floor(Math.random() * 2000) + 1; setTimeout(() =&gt; { console.log('Connection Established'); }, randomTime); } function queryData() { let randomTime = Math.floor(Math.random() * 1000) + 1; setTimeout(() =&gt; { console.log('Query Complete'); }, randomTime); }   For our code to work correctly, we must first connect to the database, then query the data. To accomplish this, we would intuitively write the code to invoke the functions in order, ie:  connectToDatabase(); queryData();   However, this poses a problem as there's no way to ensure that the logic to connect to the database happens before the query. In fact, since it takes longer to connect to the database, it's more likely that the query logic will complete first.  One way to solve this problem is to provide the &quot;queryData()&quot; function as a callback function to &quot;connectToDatabase()&quot; to be executed once the connection has been established:  function connectToDatabase(queryFunction) { let randomTime = Math.floor(Math.random() * 2000) + 1; setTimeout(() =&gt; { console.log('Connection Established'); queryFunction(); }, randomTime); }   Notice how we have added &quot;queryFunction&quot; as a parameter to the connectToDatabase() function. Once the connection has been established, we manually invoke the function using &quot;()&quot;.  Now, we can ensure that the functions are executed in order, using the code:  connectToDatabase(queryData);   ","version":"Next","tagName":"h2"},{"title":"Adding Parameters​","type":1,"pageTitle":"Callbacks","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/callbacks#adding-parameters","content":" As our code stands now, the &quot;queryData&quot; function is very simple and does not take any parameters. Why don't we try making it a little more dynamic by adding parameters to it, so that a query can be provided:  function queryData(query) { let randomTime = Math.floor(Math.random() * 1000) + 1; setTimeout(() =&gt; { console.log(query); }, randomTime); }   Now we can invoke our queryData with a given query, for example:  queryData('select * from Employees');   However, a problem occurs when we attempt to provide the &quot;queryData&quot; function as a callback to another function (in our case, the &quot;connectToDatabase&quot; function):  connectToDatabase(queryData('select * from Employees')); // TypeError: queryFunction is not a function   This is because the &quot;()&quot; syntax after the function name causes the function to execute which then passes its return value (&quot;undefined&quot;) to the connectToDatabase function. To solve this, we must pass the parameters to the &quot;queryData()&quot; callback function, as parameters to the &quot;connectToDatabase()&quot; function:  function connectToDatabase(queryFunction, query) { let randomTime = Math.floor(Math.random() * 2000) + 1; setTimeout(() =&gt; { console.log('Connection Established'); queryFunction(query); }, randomTime); }   Here, you can see that we have added the &quot;query&quot; as a 2nd parameter to the connectToDatabase function and use it as a parameter to the &quot;queryFunction&quot;.  Putting it all together, we get:  function connectToDatabase(queryFunction, query) { let randomTime = Math.floor(Math.random() * 2000) + 1; setTimeout(() =&gt; { console.log('Connection Established'); queryFunction(query); }, randomTime); } function queryData(query) { let randomTime = Math.floor(Math.random() * 1000) + 1; setTimeout(() =&gt; { console.log(query); }, randomTime); } connectToDatabase(queryData, 'select * from Employees');  ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/example-code","content":"Example Code You may download the sample code for this topic here: Handling-Asynchronous-Code","keywords":"","version":"Next"},{"title":"Welcome to Web Programming Tools And Frameworks","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Introduction/welcome","content":"Welcome to Web Programming Tools And Frameworks Welcome to Web Programming Tools and Frameworks. In this course we will be studying a wide range of technologies that are used to create dynamic content on the web. These include modern tools and libraries / frameworks that enable the programmer to quickly and efficiently create a functioning web-based application capable of responding to requests for content, reacting predictably to errors and storing / retrieving user and application data. We will be looking at what exactly a web application is and how we can use a familiar programming language (JavaScript / ECMAScript) to create and maintain one. Additionally, we will be studying how web browsers send data to and from a web server and how we can ensure that our applications are scalable, secure and robust. We will also study methods of storing and retrieving data from a data store (SQL &amp; NoSQL Databases) and how to manage state (ie: “logged-in”) information about users.","keywords":"","version":"Next"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/example-code","content":"Example Code You may download the sample code for this topic here: JavaScript-Review","keywords":"","version":"Next"},{"title":"Developer Tools & Core Technologies","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies","content":"","keywords":"","version":"Next"},{"title":"Visual Studio Code​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#visual-studio-code","content":"   “Visual Studio Code is an open-source (free) streamlined code editor with support for development operations like debugging, task running and version control. It aims to provide just the tools a developer needs for a quick code-build-debug cycle and leaves more complex workflows to fuller featured IDEs”. Visual Studio Code also runs on Mac OS X, Linux and Windows operating systems, which will provide the class with a single unified environment to work in regardless of a student’s choice of laptop or home computer. Some of the noteworthy features of Visual Studio Code Include:  ","version":"Next","tagName":"h2"},{"title":"Integrated Terminal​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#integrated-terminal","content":" “In Visual Studio Code, you can open an integrated terminal, initially starting at the root of your workspace. This can be very convenient as you don’t have to switch windows or alter the state of an existing terminal to perform a quick command line task”.  To open the terminal:  Use the keyboard shortcut Ctrl + `Use the View | Toggle Integrated Terminal menu command.  ","version":"Next","tagName":"h3"},{"title":"Smart Editing​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#smart-editing","content":" VS Code comes with a built-in JavaScript language service so you get JavaScript code intelligence out-of-the-box. Language services provide the code understanding necessary for features like:  IntelliSense: (suggestions)smart code navigation (Go to Definition, Find All References, Rename Symbol)  ","version":"Next","tagName":"h3"},{"title":"File & Folder Based​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#file--folder-based","content":" Since VS Code is file and folder based – you can get started immediately by simply opening a file or folder in VS Code.  “On top of this, VS Code can read and take advantage of a variety of project files defined by different frameworks and platforms. For example, if the folder you opened in VS Code contains one or more package.json (which we will be making extensive use of during the semester), project.json, tsconfig.json, or .NET Core Visual Studio solution and project files, VS Code will read these files and use them to provide additional functionality, such as rich IntelliSense in the editor”.  ","version":"Next","tagName":"h3"},{"title":"Version Control​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#version-control","content":" Visual Studio Code has integrated Git support for some of the most common commands, making it easy to verify and commit code changes (see &quot;Git&quot; below).  ","version":"Next","tagName":"h3"},{"title":"Modern Web Browser​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#modern-web-browser","content":"  A modern web browser such as Google Chrome or Mozilla Firefox will be used regularly throughout this course. Microsoft Edge will work as well, as it supports a similar set of development tools, however due to it’s lack of plugins / addons and cross-platform support it’s not as highly recommended. All screenshots and development examples used throughout this course have been taken in Google Chrome.  ","version":"Next","tagName":"h2"},{"title":"Browser Developer Toolbar​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#browser-developer-toolbar","content":" Before starting this course, students should have at least a basic understanding of the Developer Tools built into a modern web browser. Typically, pressing the F12 Key (Windows) will open the bar, however there are alternate ways of opening it. For Google chrome:  Open the Chrome menu at the top-right of your browser window, then select Tools &gt; Developer Tools.Right-click on any page element and select Inspect.  This will bring up the Chrome “Developer Toolbar”, as seen below :    We will be working with many of these panels throughout the semester. A quick list of their functionality (from left to right, starting at the top left corner) is as follows:  \tElement Inspector: Select an element in the page to inspect it; this will cause the Developer Tools (Devtools) to switch to the “Elements” panel and highlight the rendered source code (HTML) responsible for displaying the item. This will also cause the “Styles” panel (on the right) to highlight all current CSS applied to the element Device Toolbar Toggle: Toggles the “device toolbar” on and off. This allows the developer to select a device and manually enter the pixel dimensions of the screen and scale of the page. This is useful for ensuring that the page looks correct on a variety of devices Elements Panel: Shows a view of the current page’s Document Object Model (DOM) tree as HTML. Selecting a given node (element) will highlight it in the page and show it’s applied CSS in the “Styles” panel. Developers can also modify this element and corresponding CSS (“Styles” panel) live and see the results directly in the browser. Important Note: The HTML shown in this panel isn’t necessarily the source code of the page, as it will show elements and attributes that have been dynamically added after the page is loaded. Changes to the HTML/CSS/JavaScript in this mode will not save to the source file. Sources Panel: shows a list of all items included in the page (ie: all images, CSS, JavaScript, etc) and their corresponding locations of origin. Developers can click on an item to show it’s contents in the middle (preview) panel. If the selected item is a JavaScript file, developers can (in the “debugger” panel) set breakpoints and watch variables to help identify and debug a misbehaving piece of JavaScript code. Console Panel: shows a JavaScript console pane. JavaScript calls to “console.log()” will show the resultant text in this window. Additionally, all JavaScript errors will show up in this location in red. Developers can also write small JavaScript code snippets to be executed immediately within the context of the page. Network Panel: is used to get additional insights into requested and downloaded resources. Developers can view a log that tracks all resources loaded including their corresponding status code, type, time (latency), size of the resource and the initiator of the request Performance Panel: enables a tool that allows developers to record and analyze all the activity in their applications as they run. It’s the best place to start investigating perceived performance issues. This is done by recording a timeline of every event that occurs after a page loads and analyzing the corresponding FPS, CPU, and network requests. Memory Panel: provides more detailed debugging information than the timeline by enabling developers to record detailed CPU/Memory profiles such as a “Heap Snapshot”, “Allocation instrumentation on timeline&quot; and “Allocation sampling&quot;. Application Panel: allows developers to inspect and manage client-side storage, caches, and resources. This includes: key-value pairs stored in “Local Storage”, access to IndexedDB Data (a JavaScript-based object-oriented database used to store data locally), a “Web SQL” explorer (depreciated in favour of IndexedDB), as well as access to stored cookies and cache data. This is very useful in verifying that your application is storing data correctly on the client side. Security Panel: gives an overview of a page from a security standpoint including: Certificate verification (indicating whether the site has proven its identity with a TLS certificate), Transport Layer Security (TLS) connection (Note: TLS is often referred to by the name of it’s predecessor, SSL) and Subresource security (indicating whether the site loads insecure HTTP subresources – ie: “mixed content”). Error Icon: displays the number of errors present in the “Console Pane”. To review the errors, simply switch over to the Console pane and locate the items highlighted in red. Customize Icon: controls where the Developer Toolbar should be placed relative to the browser, as well as a collection of all related settings and preferences for the tool set. Close Icon: closes the Developer Toolbar.  ","version":"Next","tagName":"h3"},{"title":"Core Technologies​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#core-technologies","content":" Additionally, we will cover a number of topics surrounding the following technologies (in no particular order):  ","version":"Next","tagName":"h2"},{"title":"JavaScript (ECMAScript)​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#javascript-ecmascript","content":"   A huge focus of this course will be on JavaScript. In fact – JavaScript will be the only official programming language that we will be studying in this course. While we will be interacting with HTML5 and CSS3, neither is considered a “programming language” in the same way that C, C++ or JavaScript is. HTML5 and CSS3 are instead considered markup languages and style sheet languages respectfully – that is, they describe presentation, whereas programming languages describe function. Regardless, we will be focusing exclusively on JavaScript and how a number of very sophisticated tools and frameworks can help us create efficient and functional web applications.  ECMAScript  Back in 1996 the JavaScript language specification was taken to Ecma (European Computer Manufacturers Association) International to develop a formal standardized specification, which other browser vendors and companies could implement and expand upon. This standardized JavaScript was dubbed “ECMAScript” and specific vendor versions of the specification were known as “dialects”, the most popular of which being “JavaScript”. When we refer to “JavaScript” we’re really referring to a dialect of ECMAScript that has been implemented in the engine / runtime environment that is running our JavaScript formatted code. For example, this includes JavaScript engines like SpiderMonkey in Firefox and v8 in Chrome.  In 2015, ECMAScript 6 was released and many important features were introduced, such as:  Arrow FunctionsClass DefinitionsBlock Scoped VariablesPromisesBinary &amp; Octal literalsModulesand many more…  Since then, development of ECMAScript has continued and new versions are released yearly. For a comprehensive list of which features are supported in specific browsers, environments and runtimes, see:  ECMAScript Compatibility Table  ","version":"Next","tagName":"h3"},{"title":"Node.js​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#nodejs","content":"   At it’s core, Node.js is an open-source, cross-platform JavaScript runtime environment built on Chrome’s V8 JavaScript engine. It is typically used for developing server-side and networking applications and has exploded as the go-to application framework for many real-time web applications. This is largely due to it’s event-driven, non-blocking I/O model which ensures that the main thread of execution is not kept waiting for slow I/O operations (ie: stopping and waiting for a database query to complete). Some major companies using it include Paypal, eBay, GoDaddy, Microsoft, Shutterstock, Uber, Wikia just to name a few.  Node.js also has an expansive package ecosystem accessible via it’s Node Package Manager (NPM) utility. We will leverage this by experimenting with a number of popular, open-source modules including:  Express.js (http://expressjs.com)EJS (https://ejs.co)Tailwind (https://tailwindcss.com)Multer (https://github.com/expressjs/multer)Sequelize (https://sequelize.org)Mongoose (https://mongoosejs.com)  ","version":"Next","tagName":"h3"},{"title":"Git​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#git","content":"   We will be using Git: a command-line tool which serves as a version control system used for tracking changes to your source code and making it available for collaboration with other developers (by leveraging online tools such as Github or GitLab). Additionally, there are many online services that connect to your published code to 3rd party cloud platforms such as Render or Netlify which can build your code and host your web application. For this class, we will be using Vercel - please see the Vercel Guide for more information.  There is a ton of information online on how to get started using Git / GitHub, such as:  An Intro to Git and GitHub for Beginners (Tutorial)Pro Git (eBook)Git and GitHub learning resources  ","version":"Next","tagName":"h3"},{"title":"PostgreSQL​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#postgresql","content":"   From the PostgreSQL site, postgresql.org:  “PostgreSQL (also known as “Postgres”) is a powerful, open source object-relational database system. It has more than 15 years of active development and a proven architecture that has earned it a strong reputation for reliability, data integrity, and correctness. It runs on all major operating systems, including Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, macOS, Solaris, Tru64), and Windows. It is fully ACID compliant, has full support for foreign keys, joins, views, triggers, and stored procedures (in multiple languages). It includes most SQL:2008 data types, including INTEGER, NUMERIC, BOOLEAN, CHAR, VARCHAR, DATE, INTERVAL, and TIMESTAMP. It also supports storage of binary large objects, including pictures, sounds, or video. It has native programming interfaces for C/C++, Java, .Net, Perl, Python, Ruby, Tcl, ODBC, among others, and exceptional documentation.  ","version":"Next","tagName":"h3"},{"title":"MongoDB​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingToolsAndFrameworks/Introduction/developer-tools-core-technologies#mongodb","content":"   MongoDB is another open-source database that we will be exploring in this course. However, unlike MySQL MongoDB is classified as a “NoSQL” database and stores its data in JSON like format rather than in tables with fixed columns. The term NoSQL comes from “Not only SQL” and is intended to mean that it is a type of database system that can store data in non traditional tabular and relational format. It is because of this that NoSQL is quickly becoming a popular alternative to traditional Relational Databases (RDBMS).  We will be exploring how we can leverage NoSQL (MongoDB) to make data management simple and intuitive as well as how it compares to traditional RDBMS systems. ","version":"Next","tagName":"h3"},{"title":"Hello World","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world","content":"","keywords":"","version":"Next"},{"title":"Node.js Globals​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world#nodejs-globals","content":" Regarding the code that we wrote, it’s very simple; however we have made an important assumption: that we have access to a global “console” object. In Node.js we have access to a number of global objects / variables in addition to the built-in objects that are built into the JavaScript language. Some of the Node.js Globals that we will be using include:  ","version":"Next","tagName":"h2"},{"title":"console​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world#console","content":" The console object provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.  Some of the key methods that we will be using are:  console.log()console.time() / console.timeEnd()console.dir()  ","version":"Next","tagName":"h3"},{"title":"process​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world#process","content":" The process object is a global instance of the EventEmitter class that provides information about, and control over, the current Node.js process. It exposes many properties, methods and events related to controlling system interactions.  Some of the key elements that we will be using are:  Methods: process.on(), process.abort(), process.kill(), process.exit()Properties: process.stdin, process.stdout, process.stderr, process.pid, process.envEvents: beforeExit, Exit, uncaughtException  ","version":"Next","tagName":"h3"},{"title":"__dirname​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world#__dirname","content":" __dirname is used to obtain name of the directory that the currently executing script resides in.  For example: if our .js file is located in /Users/pcrawford/ex1.js:  console.log(__dirname); // outputs /Users/pcrawford   ","version":"Next","tagName":"h3"},{"title":"__filename​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world#__filename","content":" __filename is used to obtain file containing the code being executed as well as the directory. This is the resolved absolute path of this code file.  For example: if our .js file is located in /Users/pcrawford/ex1.js:  console.log(__filename); // outputs /Users/pcrawford/ex1.js   ","version":"Next","tagName":"h3"},{"title":"setTimeout()​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world#settimeout","content":" The setTimeout() function will execute a piece of code (function) after a certain delay. It accepts 3 parameters:  callback Function: The function to call when the timer elapses.delay number: The number of milliseconds to wait before calling the callback[, …arg] Optional arguments to pass when the callback is called.  For example:  // outputs &quot;Hello after 1 second&quot; to the console setTimeout(function () { console.log('Hello after 1 second'); }, 1000);   ","version":"Next","tagName":"h3"},{"title":"setInterval()​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world#setinterval","content":" The setInterval() function will execute a piece of code (function) after a certain delay and continue to call it repeatedly. It accepts 3 parameters (below) and returns a timeout object  callback Function: The function to call when the timer elapses.delay number: The number of milliseconds to wait before calling the callback[, …arg] Optional arguments to pass when the callback is called.  info Unless you want the interval to continue forever, you need to call clearInterval() with the timeout object as a parameter to halt the interval  For example:  let count = 1; // global counter let maxCount = 5; // global maximum let myCountInterval = setInterval(function () { console.log('Hello after ' + count++ + ' second(s)'); checkMaximum(); }, 1000); let checkMaximum = function () { if (count &gt; maxCount) { clearInterval(myCountInterval); } };   ","version":"Next","tagName":"h3"},{"title":"URL​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world#url","content":" The URL class is used to create a new URL object by parsing the full URL string, ie:  let myURL = new URL('https://myProductInventory.com/products?sort=asc&amp;onSale=true');   Once we have a new URL object, we can access / modify aspects of it via their associated properties:  console.log(myURL); /* URL { href: 'https://myproductinventory.com/products?sort=asc&amp;onSale=true', origin: 'https://myproductinventory.com', protocol: 'https:', username: '', password: '', host: 'myproductinventory.com', hostname: 'myproductinventory.com', port: '', pathname: '/products', search: '?sort=asc&amp;onSale=true', searchParams: URLSearchParams { 'sort' =&gt; 'asc', 'onSale' =&gt; 'true' }, hash: '' */   To access the parsed query parameters (ie the &quot;search&quot; property), we can use a &quot;for...of&quot; loop to iterate over key-value pairs the &quot;searchParams&quot;: property:  for (const [key, value] of myURL.searchParams) { console.log('key: ' + key + ' value: ' + value); } /* key: sort value: asc key: onSale value: true */   ","version":"Next","tagName":"h3"},{"title":"Built-In Modules / 'require()'​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world#built-in-modules--require","content":" You may have noticed that some of the examples from the documentation include a mandatory 'require()' statement. For example, if we try to execute this simplified 'EventEmitter' sample from the documentation:  const myEmitter = new EventEmitter(); myEmitter.on('event', function () { console.log('an event occurred!'); }); myEmitter.emit('event');   we run into an error: ReferenceError: EventEmitter is not defined. As you will have guessed, this is because our running script does not know about the &quot;EventEmitter&quot; class, as it is not global. To remedy this, we can include the required class by &quot;requiring&quot; it, with the following syntax:  const EventEmitter = require('events'); const myEmitter = new EventEmitter(); myEmitter.on('event', function () { console.log('an event occurred!'); }); myEmitter.emit('event');   By using the global 'require' function, we have loaded a code &quot;module&quot; which contains code and logic that we can use in our own solutions. We will discuss modules in detail in the &quot;Web Server Introduction&quot; section (see: &quot;Modules &amp; Node Package Manager&quot;), however for now we should be aware of the following &quot;Built-In&quot; modules:  ","version":"Next","tagName":"h2"},{"title":"fs​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world#fs","content":" The 'fs' module is used to work directly with the file system (ie: read / write files, list the contents of a directory, etc). For example, if we had a CSV file with names, (ie: names.csv):  Jacob,Alexandra,Jessie,Ranya,Felix   We could read the contents of the file and convert the list into an array:  const fs = require('fs'); fs.readFile('names.csv', function (err, fileData) { if (err) console.log(err); else { namesArray = fileData.toString().split(','); console.log(namesArray); } });   Similarly, if we had a directory of images, ie: &quot;img&quot;, we could list the files using:  const fs = require('fs'); fs.readdir('img', function (err, filesArray) { if (err) console.log(err); else { console.log(filesArray); } });   ","version":"Next","tagName":"h3"},{"title":"path​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world#path","content":" The 'path' module provides utilities for working with file and directory paths. This will be useful when working with reading template files or writing uploaded files. For example, it can easily be used to safely concatenate two directories / paths together:  const path = require('path'); console.log('Absolute path to about.html'); console.log(path.join(__dirname, '/about.html')); // with leading slash console.log(path.join(__dirname, '//about.html')); // with multiple leading slashes console.log(path.join(__dirname, 'about.html')); // without leading slash console.log(path.join(__dirname, '\\about.html')); // with incorrect leading slash   ","version":"Next","tagName":"h3"},{"title":"readline​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingToolsAndFrameworks/Introduction/hello-world#readline","content":" The 'readline' module provides a way to read data from a &quot;Readable stream&quot; (such as process.stdin) one line at a time. For example, we can use this to prompt the user to enter data in the console using the following code:  const readline = require('readline'); const rl = readline.createInterface(process.stdin, process.stdout); rl.question('First Name: ', function (fName) { rl.question('Last Name: ', function (lName) { console.log('Hello: ' + fName + ' ' + lName); rl.close(); }); });  ","version":"Next","tagName":"h3"},{"title":"Promises & Async / Await","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/promises-async-await","content":"","keywords":"","version":"Next"},{"title":"Callback Review​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/promises-async-await#callback-review","content":" As a quick review of the callback logic discussed earlier, consider the following three functions:  // output &quot;A&quot; after a random time between 0 &amp; 3 seconds function outputA() { let randomTime = Math.floor(Math.random() * 3000) + 1; setTimeout(() =&gt; { console.log('A'); }, randomTime); } // output &quot;B&quot; after a random time between 0 &amp; 3 seconds function outputB() { let randomTime = Math.floor(Math.random() * 3000) + 1; setTimeout(() =&gt; { console.log('B'); }, randomTime); } // output &quot;C&quot; after a random time between 0 &amp; 3 seconds function outputC() { let randomTime = Math.floor(Math.random() * 3000) + 1; setTimeout(() =&gt; { console.log('C'); }, randomTime); }   If we were to execute them in order, ie:  outputA(); outputB(); outputC();   we would have no idea which letter would be output to the console first (&quot;A&quot;, &quot;B&quot;, or &quot;C&quot;), since each function takes a random amount of time to complete. If however, we wanted to be absolutely sure that the output of the code is in the correct order (&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) regardless of how long it takes each function to execute, we must ensure that the &quot;follow up&quot; functions are passed as parameters to the functions with the asynchronous logic (ie: &quot;callbacks&quot;). This case is more complicated because we have 3 functions, however it can still be achieved using the following code:  // output &quot;A&quot; after a random time between 0 &amp; 3 seconds function outputA(firstCallback, secondCallback) { let randomTime = Math.floor(Math.random() * 3000) + 1; setTimeout(() =&gt; { console.log('A'); firstCallback(secondCallback); }, randomTime); } // output &quot;B&quot; after a random time between 0 &amp; 3 seconds function outputB(lastCallback) { let randomTime = Math.floor(Math.random() * 3000) + 1; setTimeout(() =&gt; { console.log('B'); lastCallback(); }, randomTime); } // output &quot;C&quot; after a random time between 0 &amp; 3 seconds function outputC() { let randomTime = Math.floor(Math.random() * 3000) + 1; setTimeout(() =&gt; { console.log('C'); }, randomTime); } // invoke the functions in order outputA(outputB, outputC);   In the above code, we have ensured the correct flow of execution of the three functions by passing both follow up functions to the first function as parameters. The final function is then passed to the second function as a callback, so that it may be executed in the right order.  While this does indeed work to solve the intended problem (getting the output to happen in order: &quot;A&quot;, &quot;B&quot; then &quot;C&quot;), we have created some code which is difficult to follow, maintain and scale. For example, what happens when we add an &quot;outputD()&quot; function? We would need to pass it as well to the outputA() function as a parameter, only to get passed down the chain until it is executed in the correct context (for example, after outputC() has completed). As you can imagine, this creates a problem in our code and leaves us asking: &quot;is there a better way?&quot;  ","version":"Next","tagName":"h2"},{"title":"Promises​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/promises-async-await#promises","content":" ","version":"Next","tagName":"h2"},{"title":"Resolve & Then​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/promises-async-await#resolve--then","content":" Fortunately, JavaScript has the notion of the &quot;Promise&quot; that can help us deal with this type of situation. Put simply, a promise object is used for asynchronous computations (like the situation in the example above) and represents a value which may be available now, or in the future, or never. Basically, what this means is that we can place our asynchronous code inside a promise object as a function with specific parameters (&quot;resolve&quot; and &quot;reject&quot;). When our code is complete, we invoke the &quot;resolve&quot; function and if our code encounters an error, we can invoke the &quot;reject&quot; function. We can handle both of these situations later with the .then() method or (in the case of an error that we wish to handle) the .catch() method. To see how this concept is implemented in practice, consider the following addition to the outputA() method from above:  // output &quot;A&quot; after a random time between 0 &amp; 3 seconds function outputA() { let randomTime = Math.floor(Math.random() * 3000) + 1; return new Promise((resolve, reject) =&gt; { // place our code inside a &quot;Promise&quot; function setTimeout(() =&gt; { console.log('A'); resolve(); // call &quot;resolve&quot; because we have completed the function successfully }, randomTime); }); } // call the outputA function and when it is &quot;resolved&quot;, output a confirmation to the console outputA().then(() =&gt; { console.log('outputA resolved!'); });   Our &quot;outputA()&quot; function still behaves as it did before (outputs &quot;A&quot; to the console after a random period of time). However, our outputA() function now additionally returns a new Promise object that contains all of our asynchronous logic and its status. The container function for our logic always uses the two parameters mentioned above, ie: resolve and reject. By invoking the resolve method we are placing the promise into the fulfilled state, meaning that the operation completed successfully and the character &quot;A&quot; was successfully output to the console. We can respond to this situation using the &quot;then&quot; function on the returned promise object to execute some code after the asynchronous operation is complete! This gives us a mechanism to react to asynchronous functions that have completed successfully so that we can perform additional tasks.  ","version":"Next","tagName":"h3"},{"title":"Adding Data​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/promises-async-await#adding-data","content":" Now that we have the promise structure in place and are able to &quot;resolve&quot; the promise when it has completed it's task and &quot;then&quot; execute another function using the returned promise object (as above), we can begin to think about how to pass data from the asynchronous function to the &quot;then&quot; method. Fortunately, it only requires a little tweak to the above the above example to enable this functionality:  // output &quot;A&quot; after a random time between 0 &amp; 3 seconds function outputA() { let randomTime = Math.floor(Math.random() * 3000) + 1; return new Promise((resolve, reject) =&gt; { // place our code inside a &quot;Promise&quot; function setTimeout(() =&gt; { console.log('A'); resolve('outputA resolved!'); // call &quot;resolve&quot; because we have completed the function successfully }, randomTime); }); } // call the outputA function and when it is &quot;resolved&quot;, output a confirmation to the console outputA().then((data) =&gt; { console.log(data); });   Notice how we are able to invoke the resolve() function with a single parameter that stores some data (in this case a string with the text &quot;outputA resolved!&quot;). This is typically where we would place our freshly returned data from an asynchronous call to a web service / database, etc. The reason for this is that we will have access to it as the first parameter to the anonymous function declared inside the .then method and this is the perfect place to process the data.  ","version":"Next","tagName":"h3"},{"title":"Reject & Catch​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/promises-async-await#reject--catch","content":" It is not always safe to assume that our asynchronous calls will complete successfully. What if we're in the middle of a request and our connection is dropped or a database connection fails? To ensure that we handle this type of scenario gracefully, we can invoke the &quot;reject&quot; method instead of the &quot;resolve&quot; method and provide a reason why our asynchronous operation failed. This causes the promise to be in a &quot;rejected&quot; state and the &quot;.catch&quot; function will be invoked, where we can gracefully handle the error. The typical syntax for handling both &quot;then&quot; and &quot;catch&quot; in a promise is as follows:  // output &quot;A&quot; after a random time between 0 &amp; 3 seconds function outputA() { let randomTime = Math.floor(Math.random() * 3000) + 1; return new Promise((resolve, reject) =&gt; { // place our code inside a &quot;Promise&quot; function setTimeout(() =&gt; { console.log('-'); reject('outputA rejected!'); // call &quot;reject&quot; because the function encountered an error }, randomTime); }); } // call the outputA function and when it is &quot;resolved&quot; or &quot;rejected, output a confirmation to the console outputA() .then((data) =&gt; { console.log(data); }) .catch((reason) =&gt; { console.log(reason); });   info Calling &quot;resolve()&quot; or &quot;reject()&quot; won't immediately exit the promise and invoke the related &quot;.then()&quot; or &quot;.catch()&quot; callback - it simply puts the promise in a &quot;resolved&quot; or &quot;rejected&quot; state and code immediately following the statement will still run, ie: // ... reject(); console.log('I will still be executed'); resolve(); // This promise will not be &quot;resolved&quot;, since the resolve() call came after reject() // this also works the other way around. A promise has been &quot;settled&quot; once reject or resolve has been called // ... If we want to immediately exit the function and prevent further execution of the code within the promise, we can invoke the &quot;return&quot; statement, immediately following the &quot;resolve()&quot; or &quot;reject()&quot; call, ie: // ... reject(); return; console.log('I will not be executed'); // ...   ","version":"Next","tagName":"h3"},{"title":"Putting it Together​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/promises-async-await#putting-it-together","content":" Now that we know how the promise object and pattern can help us manage our asynchronous code, let's loop back to our original problem - ensuring that &quot;A&quot;, &quot;B&quot; and &quot;C&quot; are output in the correct order when invoking the &quot;outputA()&quot;, &quot;outputB()&quot; and &quot;outputC()&quot; functions, respectfully.  To make it more interesting, we will alter our code such that each of the functions resolve with the value if the randomTime is odd and reject with an error if randomTime is even:  // output &quot;A&quot; after a random time between 0 &amp; 3 seconds function outputA() { let randomTime = Math.floor(Math.random() * 3000) + 1; return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { randomTime % 2 ? resolve('A') : reject('Error with outputA()'); }, randomTime); }); } // output &quot;B&quot; after a random time between 0 &amp; 3 seconds function outputB() { let randomTime = Math.floor(Math.random() * 3000) + 1; return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { randomTime % 2 ? resolve('B') : reject('Error with outputB()'); }, randomTime); }); } // output &quot;C&quot; after a random time between 0 &amp; 3 seconds function outputC() { let randomTime = Math.floor(Math.random() * 3000) + 1; return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { randomTime % 2 ? resolve('C') : reject('Error with outputC()'); }, randomTime); }); }   If we wish to use the promises correctly to output the values in order and correctly handles errors, our code looks like the following (this is known as promise &quot;chaining&quot;):  outputA() .then((data) =&gt; { console.log(data); // output the result of &quot;outputA()&quot; to the console return outputB(); }) .then((data) =&gt; { console.log(data); // output the result of &quot;outputB()&quot; to the console return outputC(); }) .then((data) =&gt; { console.log(data); // output the result of &quot;outputC()&quot; to the console }) .catch((err) =&gt; { console.log(err); // output the error to the console });   Success! We always have &quot;A&quot;, followed by &quot;B&quot; and &quot;C&quot; in the console and the errors are correctly handled when they occur (preventing the subsequent promises from executing). We have the benefit of not having to alter the functions themselves at all if follow-up logic is necessary. Each function simply does its job, then reports back with the data (&quot;resolves&quot;) if it was successful or sends the error (&quot;rejects&quot;) it failed. This is a much more maintainable, scalable and cleaner approach to working with asynchronous code. This is why you will find that most modules mentioned in these notes are &quot;promise-based&quot;, ie: if their logic is asynchronous, functions provided by the module will return Promise objects.  While functions that return promises are indeed the preferred way to work with asynchronous operations in JavaScript, as you can see from the above code, working with promises can sometimes be difficult. If we wish to chain promises (in the case above) We must ensure that for every &quot;then()&quot; callback function returns the correct follow up function and it can be difficult to visually walk through the code.  ","version":"Next","tagName":"h3"},{"title":"Async & Await​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/promises-async-await#async--await","content":" To help us work with promises more easily in JavaScript, ECMAScript 2016 (ES7) released async &amp; await as an alternative to using &quot;then()&quot; and &quot;catch()&quot;  ","version":"Next","tagName":"h2"},{"title":"Putting it Together (again)​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/promises-async-await#putting-it-together-again","content":" Knowing that there is an alternative to &quot;then()&quot; and &quot;catch()&quot;, let's see how we can re-write the section of &quot;Putting it Together&quot; that makes use of the promises (we will not alter the functions themselves) using &quot;async&quot; and &quot;await&quot;. To achieve this, we must place our logic inside a function, ie &quot;showOutput()&quot; - the reason for this will be described below:  async function showOutput() { try { let A = await outputA(); console.log(A); // output the result of &quot;outputA()&quot; to the console let B = await outputB(); console.log(B); // output the result of &quot;outputB()&quot; to the console let C = await outputC(); console.log(C); // output the result of &quot;outputC()&quot; to the console } catch (err) { console.log(err); // output the error for outputA(), outputB() or outputC() to the console } } showOutput();   This is much cleaner and easier to read. By using the &quot;await&quot; operator, we're essentially saying &quot;wait for this function's returned promise to resolve&quot;. Additionally, you can see that we actually get the resolved value from the promise!  ","version":"Next","tagName":"h3"},{"title":"Using Await​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingToolsAndFrameworks/Handling-Asynchronous-Code/promises-async-await#using-await","content":" &quot;await&quot; pauses the execution of its surrounding async function until the promise is settled (that is, fulfilled or rejected). When execution resumes, the value of the await expression becomes that of the fulfilled promise. If the promise is rejected, the await expression throws the rejected value. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await  Notice how the documentation mentions the &quot;surrounding async function&quot;. This is because to actually use the &quot;await&quot; operator, it must be placed within a function marked as &quot;async&quot;. If we fail to do this and try to use await outside of an async function, we will get an error:  SyntaxError: await is only valid in async functions and the top level bodies of modules   You will also notice how the documentation mentions that if the promise is rejected, the await expression &quot;throws the rejected value&quot;. This is why we must place our &quot;await&quot; logic within a &quot;try&quot; / &quot;catch&quot; block. If we fail to do so and one of the promise-based functions is actually rejected, we will get the following error (this error also occurs if a &quot;.catch()&quot; function is missing when using then() &amp; catch()):  UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch().   info When using &quot;async&quot; to identify a function, you are implicitly returning a Promise. This is because async functions cannot exist within the normal flow of execution (since they contain asynchronous code). If you do return a value from an &quot;async&quot; function, it will be the &quot;resolved&quot; value of the returned promise: async function adder(num1, num2) { return num1 + num2; } adder(1, 2).then((result) =&gt; console.log(result)); //3  ","version":"Next","tagName":"h3"},{"title":"Object Oriented JavaScript","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/object-oriented-javascript","content":"","keywords":"","version":"Next"},{"title":"Object Literal Notation​","type":1,"pageTitle":"Object Oriented JavaScript","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/object-oriented-javascript#object-literal-notation","content":" The most simple and straight-forward way to create an object in JavaScript is to use &quot;Object Literal Notation&quot; (sometimes referred to as &quot;object initializer&quot; notation). The syntax for creating an object using this notation is as follows:  let obj = { property_1: value_1, property_2: value_2, // ..., 'property n': value_n, }; // properties can also be defined as a string`   So, if we wanted to create an object with the following properties:  name (string)age (number)occupation (string)  and methods...  setName (&quot;setter&quot; to set a new value for the &quot;name&quot; property)setAge (&quot;setter&quot; to set a new value for the &quot;age&quot; property)getName (&quot;getter&quot; to get the current value of the &quot;name&quot; property)getAge (&quot;getter&quot; to get the current value of the &quot;age&quot; property)  using &quot;Object Literal&quot; notation, we would write the code:  let architect = { name: 'Joe', age: 34, occupation: 'Architect', setName: function (newName) { this.name = newName; }, setAge: function (newAge) { this.age = newAge; }, getName: function () { return this.name; }, getAge: function () { return this.age; }, };   and access the data (properties) and functions (methods) using the following code, ie:  console.log(architect.name); // &quot;Joe&quot; // or console.log(architect.getName()); // &quot;Joe&quot;   We must use the “this” keyword whenever we refer to one of the properties of the object inside one of it’s methods. This is due to the fact that when a method is executed, &quot;age&quot; (for example) might already exist in the global scope, or within the scope of the function as a local variable. To be absolutely sure that we are referring to the correct &quot;age&quot; property of the current object, we must refer to the &quot;execution context&quot; - ie: the object that is actually making a call to this method. We know the object has an &quot;age&quot; property, so in order to be more specific about which age variable that we want to change, we leverage the keyword this. &quot;this&quot; will refer to the &quot;execution context&quot;, ie: the object that called the function! So, &quot;this.age&quot; can be read literally as &quot;the age property on this object&quot;, which is exactly the property that we wish to edit.  However, while &quot;this&quot; allows us to be specific with which properties that we refer to in our methods, it can lead to some confusing scenarios. For example, what if we added a new &quot;outputNameDelay()&quot; method to our architect object that writes the architect's name to the console after 1 second (1000 milliseconds):  // ... outputNameDelay: function(){ setTimeout(function(){ console.log(this.name); },1000); } // ... architect.outputNameDelay(); // outputs undefined   Everything looks correct and we have made proper use of the &quot;this&quot;, however because the setTimeout function is not executed as a method of our architect object, we end up with &quot;undefined&quot; as output to the console. There are a number of fixes for this issue (most noteworthy is the &quot;arrow function&quot; syntax - discussed further on) - one common way is to introduce a local variable (often named &quot;that&quot;) into the current scope that holds a reference to &quot;this&quot;  // ... outputNameDelay: function(){ let that = this; setTimeout(function(){ console.log(that.name); },1000); } // ... architect.outputNameDelay(); // outputs &quot;Joe&quot;   Now, we aren't using the &quot;this&quot; keyword from within the setTimeout() function, but rather &quot;that&quot; from our outputNameDelay function and everything works as it should! (ie, &quot;that&quot; points to architect, since it was the architect that invoked the outputNameDelay method).  ","version":"Next","tagName":"h2"},{"title":"The \"class\" keyword​","type":1,"pageTitle":"Object Oriented JavaScript","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/object-oriented-javascript#the-class-keyword","content":" If we wish to create multiple objects of the same &quot;type&quot; (ie: that have the same properties and methods, but with different values), we can leverage the &quot;class&quot; and &quot;new&quot; keywords, ie:  class Architect { name; age; occupation = 'architect'; // default value of &quot;architect&quot; for occupation constructor(setName = '', setAge = 0) { // handle missing parameters with '' and 0 this.name = setName; this.age = setAge; } setName(newName) { this.name = newName; } setAge(newAge) { this.age = newAge; } getName() { return this.name; } getAge() { return this.age; } } // define new &quot;architect objects using the &quot;new&quot; keyword with the &quot;architect&quot; class let architect1 = new Architect('Joe', 34); let architect2 = new Architect('Mary', 49); // samples of accessing properties and methods on both objects console.log(architect1.name); // &quot;Joe&quot; console.log(architect1.getName()); // &quot;Joe&quot; console.log(architect2.getName()); // &quot;Mary&quot;   Here, we specify the properties (with default values), a &quot;constructor&quot; function to take initialization parameters, as well as specify all of the methods within the &quot;class&quot; block.  ","version":"Next","tagName":"h2"},{"title":"Private Methods / Properties​","type":1,"pageTitle":"Object Oriented JavaScript","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/object-oriented-javascript#private-methods--properties","content":" Notice how we can access the &quot;name&quot; property of the new Architect objects, directly (ie: without using the &quot;getName()&quot; function)? This is because by default, all properties and methods are &quot;public&quot;. If we wish to mark properties as &quot;private&quot; (preventing the property from being accessed directly), we must add a &quot;#&quot; character to the beginning of the property or method name. For example:  class Architect { #name; #age; #occupation = 'architect'; // default value of &quot;architect&quot; for occupation constructor(setName = '', setAge = 0) { this.#name = setName; this.#age = setAge; } #privateMethod() { console.log(&quot;I'm a private method&quot;); } setName(newName) { this.#name = newName; } setAge(newAge) { this.#age = newAge; } getName() { return this.#name; } getAge() { return this.#age; } } let architect1 = new Architect('Joe', 34); console.log(architect1.#name); // SyntaxError   If we now try to access the &quot;#name&quot; property directly on an object created with this class, we get the following error:  SyntaxError: Private field '#name' must be declared in an enclosing class   ","version":"Next","tagName":"h3"},{"title":"Getters / Setters​","type":1,"pageTitle":"Object Oriented JavaScript","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/object-oriented-javascript#getters--setters","content":" If we do wish to provide direct access to the &quot;name&quot; and &quot;age&quot; properties however, we can use &quot;setters&quot; and &quot;getters&quot;. This way, we have more control over how the properties are manipulated and retrieved, internally to the class. For example, if we want controlled access to the &quot;name&quot; and &quot;age&quot; properties, we could use the following syntax:  class Architect { #name; #age; #occupation = 'architect'; // default value of &quot;architect&quot; for occupation constructor(setName = '', setAge = 0) { this.#name = setName; this.#age = setAge; } #privateMethod() { console.log(&quot;I'm a private method&quot;); } set name(newName) { this.#name = newName; } set age(newAge) { this.#age = newAge; } get name() { return this.#name; } get age() { return this.#age; } } let architect1 = new Architect('Joe', 34); console.log(architect1.name); // Joe   ","version":"Next","tagName":"h3"},{"title":"Inheritance​","type":1,"pageTitle":"Object Oriented JavaScript","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/object-oriented-javascript#inheritance","content":" A core principal of Object-Oriented Programming is &quot;inheritance&quot;:  &quot;a mechanism where you can to derive a class from another class for a hierarchy of classes that share a set of attributes and methods.&quot; https://stackify.com/oop-concept-inheritance  In JavaScript, this is implemented via the &quot;Prototype Chain&quot;:  &quot;When it comes to inheritance, JavaScript only has one construct: objects. Each object has a private property which holds a link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype, and acts as the final link in this prototype chain.&quot; https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain.  This is why we can access properties like &quot;length&quot; on a string, even though it is a primitive - it exists on the prototype of the built-in String Object. When we access the &quot;length&quot; property, a string primitive is automatically wrapped in a &quot;String&quot; object via a process known as &quot;auto-boxing&quot; and we gain access to the property on the prototype.  To see this in action, let's modify the String prototype after we create a new string primitive. Once the string primitive is &quot;auto-boxed&quot; with the String object, we should have access to whatever we add on the prototype:  let name = 'Thomas Anderson'; String.prototype.sayHello = function () { console.log('Hello from String!'); }; name.sayHello(); // Hello from String!   Now that we know a little about how inheritance is implemented in JavaScript, you might be asking: &quot;how does this work in our class definition?&quot; and &quot;do we have to modify the prototype of new objects directly?&quot;  Fortunately, JavaScript has added the &quot;extend&quot; keyword so that we do not have to. For example, if our &quot;architect&quot; class inherits from a more generic &quot;Job&quot; class, we could write the code:  class Job { #name; #age; constructor(setName = '', setAge = 0) { this.#name = setName; this.#age = setAge; } set name(newName) { this.#name = newName; } set age(newAge) { this.#age = newAge; } get name() { return this.#name; } get age() { return this.#age; } }   for the &quot;Job&quot; class and add the new functionality for the &quot;Architect&quot; class using the following code:  class Architect extends Job { #occupation = 'architect'; constructor(setName = '', setAge = 0) { super(setName, setAge); // invoke the &quot;parent&quot; constructor } #privateMethod() { console.log(&quot;I'm a private method&quot;); } } let architect1 = new Architect('Joe', 34); console.log(architect1.name);   To verify that Job is indeed part of the &quot;prototype chain&quot; of the new architect1 object, we can use the familiar &quot;prototype&quot; test from above, ie:  Job.prototype.sayHello = function () { console.log('Hello from Job!'); }; architect1.sayHello(); // Hello from Job!  ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/example-code","content":"Example Code You may download the sample code for this topic here: Managing-State-Information","keywords":"","version":"Next"},{"title":"Modern Syntax","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax","content":"","keywords":"","version":"Next"},{"title":"Functions​","type":1,"pageTitle":"Modern Syntax","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax#functions","content":" In JavaScript, functions are typically defined using either a declaration or expression and may contain either a fixed or variable list of parameters, which may or may not have default values.  However, as JavaScript evolved, additional options and features for working with functions have as well. The following sections outline some of the features that we will use in these notes:  ","version":"Next","tagName":"h2"},{"title":"Arrow Functions​","type":1,"pageTitle":"Modern Syntax","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax#arrow-functions","content":" ES6 (ECMAScript 2015) introduced a compact version of function expressions known as &quot;Arrow functions&quot;, for example:  let adder = function (num1, num2) { return num1 + num2; }; // is the same as: let adderArrow = (num1, num2) =&gt; { return num1 + num2; };   Essentially, we have removed the &quot;function&quot; keyword and replaced it with an arrow following the parameter list. While this is indeed shorter, we can compress the function expression even further as arrow functions use an &quot;implicit return&quot;. This means that if the curly brackets (&quot;{&quot; and &quot;}&quot;) are omitted from the arrow function, the inner expression is returned:  let adderArrowShort = (num1, num2) =&gt; num1 + num2;   Additionally, if there is only a single parameter, the brackets surrounding the parameters may also be omitted, ie:  let squared = num =&gt; num * num;   info If there are 0 parameters to the function, empty round brackets must be used, ie: let getHello = () =&gt; 'Hello World';   Lexical &quot;this&quot;​  Arrow functions are great for creating simplified code that is easier to read (sometimes referred to as &quot;syntax sugar&quot;), however there is another very useful and slightly misleading feature that we have yet to discuss: the notion of a &quot;lexical 'this'&quot;. Recall that when we added the &quot;outputNameDelay&quot; method to the architect object, we had to overcome the issue with &quot;this&quot; pointing at the incorrect object by introducing a new local variable, &quot;that&quot;:  outputNameDelay: function(){ let that = this; setTimeout(function(){ console.log(that.name); },1000); }   While this does solve the problem, wouldn't it be better if we didn't have to always create a new local variable to sit in for &quot;this&quot;? Fortunately, arrow functions actually use a &quot;lexical this&quot; instead of their own value for &quot;this&quot;, so functions defined using the arrow notation use the &quot;this&quot; value of their parent scope.  With this in mind, we can re-write the above function using an arrow function to achieve the same result without having to introduce any new variables to handle the &quot;this&quot; issue. Additionally, because it's such a simple function, we can transform it into a single line:  outputNameDelay: function(){ setTimeout(() =&gt; console.log(this.name), 1000); }   This is a typical use of arrow functions, ie: to simplify a scenario in which we need to declare a function in place, often as a parameter to other functions (&quot;callbacks&quot;). We don't have to concern ourselves with how &quot;this&quot; will behave in the new context and the added &quot;syntax sugar&quot; makes the operation much simpler to read and shorter to code.  ","version":"Next","tagName":"h3"},{"title":"Destructuring Object Parameters​","type":1,"pageTitle":"Modern Syntax","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax#destructuring-object-parameters","content":" Another common feature introduced in ES6 is the ability to perform a &quot;destructuring assignment&quot; for objects. For example, if we have the following code that defines a &quot;product&quot; object:  let product = { id: '145be9', price: 1.35, onSale: false, };   and we wish to extract the &quot;price&quot; and &quot;id&quot; values into separate variables, we would typically use the following syntax:  let price = product.price; let id = product.id;   However, this can be shortened to the following, using a &quot;destructuring assignment&quot;:  let { price, id } = product;   This type of syntax is commonly used when passing object properties as parameters to functions. For example, instead of the following code:  function outputProduct(productObj) { console.log('Product', productObj.id, productObj.price); }   we could use the more concise:  function outputProduct({ id, price }) { console.log('Product', id, price); }   ","version":"Next","tagName":"h3"},{"title":"Arrays​","type":1,"pageTitle":"Modern Syntax","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax#arrays","content":" ","version":"Next","tagName":"h2"},{"title":"Iterating​","type":1,"pageTitle":"Modern Syntax","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax#iterating","content":" An Array in JavaScript is technically an &quot;indexed collection&quot;, ie: &quot;an ordered list of values that you refer to with a name and an index&quot;. Because of this, the simplest ways to iterate over the collection are with the common for loop and do...while / while loops. However, there are other ways to iterate over an array, including:  for...of loop​  The for...of statement &quot;executes a loop that operates on a sequence of values sourced from an iterable object. Iterable objects include instances of built-ins such as Array, String, TypedArray, Map, Set, NodeList (and other DOM collections), as well as the arguments object, generators produced by generator functions, and user-defined iterables.&quot;  let sample = ['A', 'B', 'C']; for (const element of sample) { console.log(element); }   forEach() Method​  The forEach() method of the Array object can be used to execute a function once per element of the array, with the element (and optionally, the index) as the parameter(s), for example:  let sample = ['A', 'B', 'C']; sample.forEach((element, index) =&gt; console.log(element + ' at index: ' + index));   info There are many other methods similar to &quot;forEach&quot; that serve to: Filter the arrayFind elements in the arrayReduce the array to a single valueTest if the array contains some element that meets a specific criteriaTest if every element of the array meets a specific criteriaand so on...  ","version":"Next","tagName":"h3"},{"title":"Destructuring Elements​","type":1,"pageTitle":"Modern Syntax","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax#destructuring-elements","content":" As we have seen above, ES6 introduced the &quot;destructuring assignment&quot;. We used this feature to make the syntax for extracting properties from objects more concise and to clarify function parameters. Fortunately, this feature is also available for arrays using a similar process:  let sample = ['A', 'B', 'C']; // let a = sample[0]; // let b = sample[1]; let [a, b] = sample;   Here, we assign the variables a &amp; b at the same time by &quot;destructuring&quot; the array. This syntax is popular in libraries such as React (for example, when using the common &quot;useState&quot; hook&quot;), so it's important that we become familiar with it.  ","version":"Next","tagName":"h3"},{"title":"Spread Syntax​","type":1,"pageTitle":"Modern Syntax","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax#spread-syntax","content":" You have likely seen the &quot;...&quot; syntax before in JavaScript. A common use for it is in the form of &quot;rest&quot; parameters, which allow for the creation of functions that take on an unknown number of parameters:  function sum(...numbers) { let total = 0; for (const num of numbers) total += num; return total; } console.log(sum(1, 2, 3, 4, 5, 6)); // 21   However, &quot;...&quot; can also be used outside of function parameters as a placeholder for values in an array (or properties in an object). This is commonly referred to as &quot;spread&quot; syntax. For example, if we wished to merge two arrays to create a new array (without using the built-in &quot;concat&quot; function), one option is to use the following code:  let sample1 = ['A', 'B', 'C']; let sample2 = ['D', 'E', 'F']; let sample3 = []; sample1.forEach((element) =&gt; sample3.push(element)); sample2.forEach((element) =&gt; sample3.push(element)); console.log(sample3); // [ 'A', 'B', 'C', 'D', 'E', 'F' ]   Here, we must loop through each array and add each element in turn to a new array. However, using the &quot;spread&quot; syntax, we can instead use the following code:  let sample1 = ['A', 'B', 'C']; let sample2 = ['D', 'E', 'F']; let sample3 = [...sample1, ...sample2]; console.log(sample3); // [ 'A', 'B', 'C', 'D', 'E', 'F' ]   By using the &quot;...&quot; syntax, we're essentially saying &quot;the elements of the array&quot;.  info This can be used for objects as well, ie: let product = { id: '145be9', price: 1.35, onSale: false, }; let productWithStore = { ...product, store: '53' }; console.log(productWithStore); // { id: '145be9', price: 1.35, onSale: false, store: '53' }   It is important to note however, that while we are using the &quot;...&quot; to create a new copy of arrays / objects, it is only a &quot;shallow&quot; copy (ie: it will not copy &quot;nested&quot; elements and properties, leaving a reference to the original array / object).  ","version":"Next","tagName":"h3"},{"title":"Strings​","type":1,"pageTitle":"Modern Syntax","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax#strings","content":" ","version":"Next","tagName":"h2"},{"title":"Template Literals​","type":1,"pageTitle":"Modern Syntax","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax#template-literals","content":" A common way to place text and data together in a single string in JavaScript is to use the &quot;+&quot; operator. For example:  let x = 5, y = 6; console.log(x + &quot; + &quot; + y + &quot; = &quot; + (x + y)); // 5 + 6 = 11   However, wouldn't it be simpler if we could have a single string with placeholders for data, rather than multiple strings placed next to data, concatenated using the &quot;+&quot; operator?  Fortunately, ES6 has introduced &quot;Template literals&quot; sometimes called &quot;Template strings&quot;, which use the ( ` ) character to define the string and the &quot;${expression}&quot; syntax to insert an expression into the string to be evaluated.  Using this, we can re-write our above example to remove the &quot;+&quot; operator and instead use the more concise (and easier to read):  let x = 5, y = 6; console.log(`${x} + ${y} = ${x + y}`); // 5 + 6 = 11   Additionally, since the &quot;${}&quot; syntax within the template literal allows to evaluate an expression, we can also execute functions and other logic within the string definition, such as:  let shapes = ['circle', 'square', 'triangle']; console.log(`My favourite shapes are:${shapes.map((shape, index) =&gt; ` ${index + 1}: ${shape}`)}`); // My favourite shapes are: 1: circle, 2: square, 3: triangle   info We also have the added bonus of creating multi-line strings, ie: let myString = `Hello World`; console.log(myString); // Hello // World   ","version":"Next","tagName":"h3"},{"title":"Errors​","type":1,"pageTitle":"Modern Syntax","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax#errors","content":" One of the most important aspects of writing any program is elegantly handling errors. It is important to never let your program suddenly crash or enter an unknown state due to an unanticipated error. JavaScript features numerous mechanisms to handle certain types of logical errors; for example the global isNaN() function is a way to elegantly respond to a situation in which a number was expected, but not returned:  let x = 'twenty'; let y = parseInt(x); if (isNaN(y)) { console.log('x cannot be converted to a number'); } else { console.log(`success! the numeric value of x is: ${y}`); }   Similarly, we can use the global isFinite() function to handle a situation where division by zero has occurred:  let x = 30, y = 0; let z = x / y; if (isFinite(z)) { console.log(`success! ${x} / ${y} = ${z}`); } else { console.log(`${x} is not divisible by ${y}`); }   ","version":"Next","tagName":"h2"},{"title":"try / catch​","type":1,"pageTitle":"Modern Syntax","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax#try--catch","content":" While the above functions are extremely useful for handling logical errors, they are not sophisticated enough to handle a situation that would completely break your code and cause the program to fail. For example, consider the following example that uses our new &quot;const&quot; keyword:  const PI = 3.14159; console.log('trying to change PI!'); PI = 99; console.log(`Haha! PI is now: ${PI}`);   Here, we are trying to change the value of a constant: PI. If we try to run this short program in Node.js, the program will crash before we get a chance to see the string &quot;Haha! PI is now: 99&quot;, or even &quot;Haha! PI is now: 3.14159&quot;. There is no elegant recovery and we do not get to exit the program gracefully. This can be a huge problem if, for example we were working with a live connection to a service and an unexpected error occurred. Our program would crash and we would not be able to respond to the error by alerting the user and properly closing the connection. Fortunately, before our program crashes in such a way, Node.js will &quot;throw&quot; an &quot;Error&quot; object that we can intercept using the &quot;try...catch&quot; statement:  const PI = 3.14159; console.log('trying to change PI!'); try { PI = 99; } catch (ex) { console.log('uh oh, an error occurred!'); } console.log(`Alas, it cannot be done, PI remains: ${PI}`);   If we execute the above code in Node.js we will find that our program doesn't crash and that our string: &quot;Alas, it cannot be done, PI remains: 3.14159&quot; gets correctly logged to the terminal! Additionally, we can execute a specific block of code right when the error is encountered; in this case we output &quot;uh oh, an error occurred!&quot;. This is not very useful to help us debug the error, but it better than having the program crash and at least we know that an error did indeed occur. If we wish to obtain additional information about the error, we can make use of some of the properties / methods of the Error object that was thrown as an exception and caught in our &quot;catch&quot; block. For example, we can alter the code to use the &quot;message&quot; property of the caught exception (ex) to display a more helpful error:  const PI = 3.14159; console.log('trying to change PI!'); try { PI = 99; } catch (ex) { console.log(`uh oh, an error occurred: ${ex.message}`); // outputs: uh oh, an error occurred: Assignment to constant variable. } console.log(`Alas, it cannot be done, PI remains: ${PI}`);   By utilizing properties such as Error.message &amp; Error.stack, we can gain further insight to exactly what went wrong and we can either refactor our code to remedy the error, or acknowledge that the error will happen and handle it gracefully.  Lastly, if we have some code that we would like to execute regardless of whether or not the code in our &quot;try&quot; block is successful, we can use a &quot;finally&quot; block:  const PI = 3.14159; console.log('trying to change PI!'); try { PI = 99; } catch (ex) { console.log(`uh oh, an error occurred: ${ex.message}`); // outputs: uh oh, an error occurred: Assignment to constant variable. } finally { console.log('always execute code in this block'); } console.log(`Alas, it cannot be done, PI remains: ${PI}`);   ","version":"Next","tagName":"h3"},{"title":"Throwing Errors​","type":1,"pageTitle":"Modern Syntax","url":"/WebProgrammingToolsAndFrameworks/JavaScript-Review/modern-syntax#throwing-errors","content":" Now that we know how to correctly handle errors that have been thrown by the Node.js runtime environment or by other code / modules included in our solutions, why don't we try throwing our own exceptions? This is very straightforward and only requires the use of the &quot;throw&quot; keyword and (typically) an Error Object:  function divide(x, y) { if (y == 0) { throw new Error('Division by Zero!'); } return x / y; } let a = 3, b = 0, c; try { c = divide(a, b); } catch (ex) { console.log(`uh oh, an error occurred: ${ex.message}`); // outputs: uh oh, an error occurred: Division by Zero! c = NaN; } console.log(`${a} / ${b} = ${c}`); // 3 / 0 = NaN   Notice how the code below the &quot;throw&quot; statement does not get executed, and the flow of execution goes directly into the catch block. This prevents the error from propagating and ensures that it is handled immediately. As you can see, we can throw a new error whenever we detect that an error may occur anywhere in our code. In the above example, we check if our second parameter (y) is zero (0) and rather than trying to do the division, we immediately throw a custom error with the message &quot;Division by Zero!&quot;. If the function call exists in a &quot;try&quot; block ( as above ), the execution of the code will immediately continue in the &quot;catch&quot; block and we mitigate the error by setting &quot;c&quot; to NaN. ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/example-code","content":"Example Code You may download the sample code for this topic here: NoSQL-Database-MongoDB","keywords":"","version":"Next"},{"title":"Key Terminology","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/key-terminology","content":"","keywords":"","version":"Next"},{"title":"Cookies​","type":1,"pageTitle":"Key Terminology","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/key-terminology#cookies","content":" Recall from Advanced Routing &amp; Middleware, &quot;cookies&quot; are pieces of data that are passed back and forth from the browser to the server that hold state information about the current audience interacting with your application.  Each time a request is made from the browser or a response is sent from the server, a set of headers is included. Request headers contain the 'Cookie' header and response headers contain the 'Set-Cookie' header. These headers are a string of semicolon separated values that can be referenced in server side code using the ‘req’ object. The most common type of data we want to place in the cookie is a &quot;session&quot; value.  Here is an example of what a cookie might look like in the request header when inspecting it in the Chrome dev tools  Cookie: COOKIE_CONSENT_ACCEPTED=true; PS_DEVICEFEATURES=width:1680 height:1050 pixelratio:2 touch:0 geolocation:1 websockets:1 webworkers:1 datepicker:1 dtpicker:1 timepicker:1 dnd:1 sessionstorage:1 localstorage:1 history:1 canvas:1 svg:1 postmessage:1 hc:0 maf:0; AWSELB=25B9EB610A4727BBBAAA553BD60CC37D8297F3411BEB083D3A756E7C927A16B55DE1AF9292A34C533329A16DEEFAB2D1F0A8885F83FB98BB17D96810C5F56F19DD91CE2710; AWSELBCORS=25B9EB610A4727BBBAAA553BD60CC37D8297F3411BEB083D3A756E7C927A16B55DE1AF9292A34C533329A16DEEFAB2D1F0A8885F83FB98BB17D96810C5F56F19DD91CE2710; BbClientCalenderTimeZone=America/Toronto; JSESSIONID=30A73795E59C58AA9DE10E9A55611D84; samlCookie=33323A4F65773352327570346E792F7138547478616F417A38613172304E6A797A517065457A74684F574E746F476C59412B474F4E7963465151695275304D49526E72; BbRouter=expires:1692983209,id:FA96503450967749E204905096629DDA,sessionId:4644480316,signature:b0f5dc80530391a6aaa921cf7e2f29bc18af9e19b62e6f9a34d5287cb910f86c,site:47804be6-4f5a-41e6-9752-f1324b876acb,timeout:10800,user:94048796fad9425cb85b38fe6cc9a794,v:2,xsrf:a2aaa822-9f18-49ef-b62c-911a845d78c5  And here is an example of the ‘Set-Cookie’ header in a response from the server to update it after a request  Set-Cookie: BbRouter=expires:1692983219,id:FA96503450967749E204905096629DDA,sessionId:4644480316,signature:7aa65c9e8d01384c96897743bc1ef4ff919b0342f37c8f8e0525c6566aa411fb,site:47804be6-4f5a-41e6-9752-f1324b876acb,timeout:10800,user:94048796fad9425cb85b38fe6cc9a794,v:2,xsrf:a2aaa822-9f18-49ef-b62c-911a845d78c5; Path=/; Secure; HttpOnly  Notice how the 'Cookie' header contains a session ID and digital signature. It may also contain other elements depending on what the app intends to retain in the 'state' between user requests. In the above case, an 'encrypted session' is utilized (which is why we're unable to read it). This is extremely important in a production environment, as we do not want sensitive user information to be compromised if the cookie is accessed by a third party. As a general rule, all sessions that persist between the client and server should be encrypted and transmitted exclusively over HTTPS. We will cover HTTPS encryption in &quot;Security Considerations&quot;.  ","version":"Next","tagName":"h2"},{"title":"Sessions​","type":1,"pageTitle":"Key Terminology","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/key-terminology#sessions","content":" Implementing sessions is fairly straightforward in Express.js. The platform is mature and libraries have been tested with thousands of websites and billions of logins. These libraries are easy to use and integrate into your own projects.  A popular library for implementing client sessions is Mozilla’s &quot;client sessions&quot; Node library. This library focuses on keeping sessions between the client and server on the client. This has several advantages over storing and keeping track of them in memory on the server. For example, if the server restarts and you have not yet saved session information in a persistent storage location, it will be lost and all your users will be logged out.  It is also beneficial to keep your sessions on the client (and have them continuously sent with each request), as this enables you to host a website or app with multiple web servers, while ensuring the session remains active regardless of the server used to process the response. If this were not the case, we must ensure each users’ requests are always sent to the same web server to preserve their session. Alternatively, you could attempt to replicate server session information between web servers, however this can be very complex. For these reasons, storing the session on the client makes scaling and session management a lot easier.  ","version":"Next","tagName":"h2"},{"title":"Authentication vs Authorization​","type":1,"pageTitle":"Key Terminology","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/key-terminology#authentication-vs-authorization","content":" Authentication and Authorization mean two entirely different things. It can be easy to confuse them, so let’s discuss them a little bit before we begin to implement sessions and secure routes. This will enable you to be more comfortable explaining and debugging the two different concepts.  Authentication is the answer to “Who are you?”. It involves supplying credentials to identify yourself to the server and establish a session for your user account.  Authorization is the answer to “What do you have access to?”. It involves checking your permissions to resources you have requested and acting accordingly. You may be authenticated with the server and have a user session but you might not be authorized to view a certain resource. (No permissions!)  Here is quick video from MongoDB University that explains it nicely. MongoDB also has the concept of authentication and authorization.    ","version":"Next","tagName":"h2"},{"title":"Status codes​","type":1,"pageTitle":"Key Terminology","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/key-terminology#status-codes","content":" There are a number of standard http response status codes that can be used by your application to inform the browser of whether a request was rejected because of an authentication problem or an authorization problem.  401 (Unauthorized): Authentication error. The resource exists but it requires the user to be authenticated first to view it. It may also require permissions and be checked again after authenticating for proper authorization. 403 (Forbidden): Authorization error. The resource exists but the user does not have permission to view it. 404 (Not Found): The resource that was requested was not found on the server. This is commonly used when a url is requested that simply doesn’t exist. ","version":"Next","tagName":"h2"},{"title":"Introduction to MongoDB","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/introduction-to-mongodb","content":"","keywords":"","version":"Next"},{"title":"NoSQL vs Traditional SQL​","type":1,"pageTitle":"Introduction to MongoDB","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/introduction-to-mongodb#nosql-vs-traditional-sql","content":" As we have seen, one of the major differences between NoSQL and traditional SQL systems is the way the data is structured, ie: SQL databases are table-based. This means they use a rigid schema where data is organized into tables with rows and columns and primary / foreign keys to establish relationships between them. NoSQL databases however, can have different structures such as document-oriented (in the case of MongoDB), key-value pairs, or graph structures. In a NoSQL database, a document can contain key-value pairs and can be ordered and nested. Ths leads to additional benefits mentioned above, such horizontal scaling and fast queries.  Before we get started with MongoDB, we should be familiar with how some of the terms translate to traditional RDBMS:  RDBMS term\tMongoDB termTable\tCollection Record\tDocument Column\tField Joins\tEmbed data or link to another collection  See: MongoDB vs. MySQL Differences  ","version":"Next","tagName":"h2"},{"title":"Setting up a MongoDB Atlas account​","type":1,"pageTitle":"Introduction to MongoDB","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/introduction-to-mongodb#setting-up-a-mongodb-atlas-account","content":" MongoDB Atlas is a free online service that hosts MongoDB in the cloud:  MongoDB Atlas is a multi-cloud database service by the same people that build MongoDB. Atlas simplifies deploying and managing your databases while offering the versatility you need to build resilient and performant global applications on the cloud providers of your choice. https://www.mongodb.com/docs/atlas  To get started, open https://www.mongodb.com/cloud/atlas and click the &quot;Try free&quot; button.  This will take you to the &quot;register&quot; page, where you can either create an account with Atlas, or sign in with Google. If you prefer to sign in with GitHub, you can proceed directly to: https://account.mongodb.com/account/login and click the &quot;GitHub&quot; button.  Once you have logged in, you should be prompted to &quot;Create a deployment&quot;. To begin:  Click the &quot;+ Create&quot; button to continue. At the next screen, we will see the &quot;Deploy your database&quot; options. Be sure to Choose the &quot;FREE&quot; option before clicking the large, green &quot;Create&quot; button: You will then be taken to the &quot;Security Quickstart&quot; screen, which should have the &quot;Username and Password&quot; option checked with a form containing pre-filled values for the &quot;Username&quot; and &quot;Password&quot;. Write these down as we will need them later, and click the green &quot;Create User&quot; button With this section complete, you should be taken to a &quot;Where would you like to connect from?&quot; screen with &quot;My Local Environment&quot; selected and an &quot;IP Access List&quot;. For now, we will allow access from anywhere, so ensure that you enter the following values &quot;0.0.0.0/0&quot; and &quot;any&quot; before clicking the &quot;Add Entry&quot; button: Finally, click the &quot;Finish and Close&quot; button  ","version":"Next","tagName":"h2"},{"title":"Obtaining your Connection String​","type":1,"pageTitle":"Introduction to MongoDB","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/introduction-to-mongodb#obtaining-your-connection-string","content":" Once your cluster has been created, you should be taken to the &quot;Overview&quot; screen, where we can view our deployments.    From here, click the &quot;CONNECT&quot; button and choose the &quot;Drivers&quot; option Scroll down to &quot;3. Add your connection string into your application code&quot; and write down the connection string (we will need it later) - it should look something like: mongodb+srv://user:&lt;password&gt;@cluster0.abc123.mongodb.net/?retryWrites=true&amp;w=majority Finally, replace the &lt;password&gt; value with the password recorded from earlier, ie: mongodb+srv://user:yourPassword@cluster0.abc123.mongodb.net/?retryWrites=true&amp;w=majority and click the &quot;Close&quot; button to return to the &quot;Overview&quot; screen. ","version":"Next","tagName":"h2"},{"title":"Introduction to \"Client Sessions\"","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/introduction-to-client-sessions","content":"","keywords":"","version":"Next"},{"title":"The \"client-sessions\" Library​","type":1,"pageTitle":"Introduction to \"Client Sessions\"","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/introduction-to-client-sessions#the-client-sessions-library","content":" The &quot;client-sessions&quot; library is available on NPM and can be included in our project using the familiar steps to install:  npm install client-sessions   and 'require' it in our code  const clientSessions = require('client-sessions');   ","version":"Next","tagName":"h2"},{"title":"Middleware​","type":1,"pageTitle":"Introduction to \"Client Sessions\"","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/introduction-to-client-sessions#middleware","content":" Once we have a reference to &quot;clientSessions&quot;, we register it as middleware and configure it using the &quot;cookieName&quot;, &quot;secret&quot;, &quot;duration&quot; and &quot;activeDuration&quot; properties:  app.use( clientSessions({ cookieName: 'session', // this is the object name that will be added to 'req' secret: 'o6LjQ5EVNC28ZgK64hDELM18ScpFQr', // this should be a long un-guessable string. duration: 2 * 60 * 1000, // duration of the session in milliseconds (2 minutes) activeDuration: 1000 * 60, // the session will be extended by this many ms each request (1 minute) }) );   ","version":"Next","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"Introduction to \"Client Sessions\"","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/introduction-to-client-sessions#testing","content":" To ensure that clientSessions is working properly, add the following simple routes and start the server:  app.get('/session-test-add', (req, res) =&gt; { req.session.message = req.query.message || ''; // add a &quot;message&quot; property to the session res.send(&quot;session created with using 'message' query parameter&quot;); }); app.get('/session-test-read', (req, res) =&gt; { res.send(`session message: ${req.session.message}`); // read the &quot;message&quot; property from the session });   When you navigate to the &quot;/session-test-add&quot; route with a &quot;message&quot; query parameter, ie: /session-test-add?message=Hello World! You should see that a &quot;Set Cookie&quot; header was sent in the response with a value that should look like the following: session=25uFcTuHZzZlSWntEs-Kzg.D96gsJqB0lLKj4DBZsc3KSj4Z4_76pkoCy4uXUqgS1C4uuHbaxMZ6l9dTCWu-ijc.1692988779453.120000.FprcH5eIT-o6Iedv-vP2i0P8HmzCRMXGdm813oveVBc; path=/; expires=Fri, 25 Aug 2023 18:41:40 GMT; httponly This confirms that our session value was indeed encrypted and sent to the client. To test whether or not our server can read it, navigate to the other route: /session-test-read You should see the response text: &quot;session message: Hello World!&quot;. Additionally, you should see that a &quot;Cookie&quot; header was sent in the request with a value like: session=AqnLAnL7dqAr9QqXnpD5Xw.wcCqiCvVSRgllI1mLOAC9yHmjjLygsur7AQaKX50_9vkugEnTKhhz3V4U8V_xgFa.1692989253302.120000.kCRDEuDgPpEuEsuEVF-2vR3vKILSPluM8tyaghTnYCE   ","version":"Next","tagName":"h3"},{"title":"Practical Application​","type":1,"pageTitle":"Introduction to \"Client Sessions\"","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/introduction-to-client-sessions#practical-application","content":" We can now confirm that &quot;client sessions&quot; is working correctly - we are able to add values to the session, which are encrypted and sent to the client using a &quot;cookie&quot;. As a more practical test of this technology, we will implement a simple app with a &quot;login&quot; view and a protected &quot;dashboard&quot; view that may only be accessed once the user has logged in.  To begin, create a simple web server using Express, making sure to also install and configure EJS (see: &quot;Template Engines&quot; - EJS).  ","version":"Next","tagName":"h2"},{"title":"Routes​","type":1,"pageTitle":"Introduction to \"Client Sessions\"","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/introduction-to-client-sessions#routes","content":" The server should have three routes:  GET &quot;/login&quot; - renders a &quot;login.ejs&quot; file with an empty &quot;message&quot; app.get('/login', (req, res) =&gt; { res.render('login', { message: '' }); }); POST &quot;/login&quot; - renders a &quot;/login.ejs&quot; file with an &quot;invalid login&quot; message app.post('/login', (req, res) =&gt; { res.render('login', { message: 'invalid login' }); }); GET &quot;/dashboard&quot; - renders a &quot;dashboard.ejs&quot; file with a &quot;user&quot; object from the session app.get('/dashboard', (req, res) =&gt; { res.render('dashboard', { user: req.session.user }); });   ","version":"Next","tagName":"h3"},{"title":"Templates​","type":1,"pageTitle":"Introduction to \"Client Sessions\"","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/introduction-to-client-sessions#templates","content":" Next, we must create our two EJS template files: &quot;login.ejs&quot; and &quot;dashboard.ejs&quot; in a views directory:  views/login.ejs &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Log In&lt;/h1&gt; &lt;hr /&gt; &lt;br /&gt; &lt;form method=&quot;post&quot; action=&quot;/login&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;User Name&quot; name=&quot;userName&quot; /&gt; &lt;input type=&quot;password&quot; placeholder=&quot;Password&quot; name=&quot;password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Log In&lt;/button&gt; &lt;/form&gt; &lt;br /&gt; &lt;%= message %&gt; &lt;/body&gt; &lt;/html&gt; views/dashboard.ejs &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Dashboard&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Dashboard&lt;/h1&gt; &lt;hr /&gt; &lt;br /&gt; &lt;h3&gt;Hello &lt;%= user.userName %&gt;&lt;/h3&gt; &lt;p&gt;Welcome to your dashboard&lt;/p&gt; &lt;p&gt;Here is the information we have on file for you:&lt;/p&gt; &lt;h4&gt;userName: &lt;%= user.userName %&gt;&lt;/h4&gt; &lt;h4&gt;email: &lt;%= user.email %&gt;&lt;/h4&gt; &lt;a href=&quot;/logout&quot;&gt;Logout&lt;/a&gt; &lt;/body&gt; &lt;/html&gt;   ","version":"Next","tagName":"h3"},{"title":"Middleware​","type":1,"pageTitle":"Introduction to \"Client Sessions\"","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/introduction-to-client-sessions#middleware-1","content":" The next part of our application is the middleware. We will require:  The built-in urlencoded middleware: app.use(express.urlencoded({ extended: true })); The client-sessions middleware - installed using NPM and included using: const clientSessions = require(&quot;client-sessions&quot;); app.use( clientSessions({ cookieName: 'session', // this is the object name that will be added to 'req' secret: 'o6LjQ5EVNC28ZgK64hDELM18ScpFQr', // this should be a long un-guessable string. duration: 2 * 60 * 1000, // duration of the session in milliseconds (2 minutes) activeDuration: 1000 * 60, // the session will be extended by this many ms each request (1 minute) }) ); Custom middleware, used to protect a route from unauthorized access: function ensureLogin(req, res, next) { if (!req.session.user) { res.redirect('/login'); } else { next(); } }   ","version":"Next","tagName":"h3"},{"title":"Route Updates (Logic)​","type":1,"pageTitle":"Introduction to \"Client Sessions\"","url":"/WebProgrammingToolsAndFrameworks/Managing-State-Information/introduction-to-client-sessions#route-updates-logic","content":" The final piece of our application is to add some logic to our routes. Specifically, we should add logic to validate the userName / password combination against a predefined (hard-coded) user. If the user is authenticated, a session should be created which gives them access to the &quot;dashboard&quot; route.  To begin, let's add our &quot;ensureLogin&quot; middleware function to the &quot;/dashboard&quot; route to prevent unauthorized access:  app.get('/dashboard', ensureLogin, (req, res) =&gt; { res.render('dashboard', { user: req.session.user }); });   Next, we will update our POST &quot;/login&quot; route to authenticate the &quot;userName&quot; and &quot;password&quot; values from the login form against a mock user. If the credentials match, create a session for the user, otherwise re-render the &quot;login&quot; template with the error message.  app.post('/login', (req, res) =&gt; { let mockUser = { userName: 'sampleuser', password: 'samplepassword', email: 'sampleuser@example.com', }; if (req.body.userName == mockUser.userName &amp;&amp; req.body.password == mockUser.password) { req.session.user = { userName: mockUser.userName, email: mockUser.email, }; res.redirect('/dashboard'); } else { res.render('login', { message: 'invalid login' }); } });   info If we also wish to implement &quot;log out&quot; functionality, we could reset the session with the following code: req.session.reset();  ","version":"Next","tagName":"h3"},{"title":"Operations (CRUD) Reference","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/operations-crud-reference","content":"","keywords":"","version":"Next"},{"title":"Create​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/operations-crud-reference#create","content":" To &quot;save&quot; (create) a new document, we must first create the document in code using the model we want (ie: &quot;Company&quot;). Then we can call a built in method, &quot;save&quot; on the new object to save it.  const kwikEMart = new Company({ ... }); kwikEMart.save().then(() =&gt; { // everything good console.log(&quot;kwikEMart saved&quot;); }).catch(err =&gt; { // there was an error console.log(err); });   ","version":"Next","tagName":"h2"},{"title":"Read​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/operations-crud-reference#read","content":" To &quot;find&quot; (read) documents from the database, we use the &quot;find&quot; method on the model object itself (ie: &quot;Company&quot;), ie:  Company.find({ companyName: 'The Kwik-E-Mart' }) //.sort({}) //optional &quot;sort&quot; - https://docs.mongodb.com/manual/reference/operator/aggregation/sort/ .exec() .then((companies) =&gt; { // companies will be an array of objects. // Each object will represent a document that matched the query console.log(companies); });   ","version":"Next","tagName":"h2"},{"title":"Selecting specific fields​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/operations-crud-reference#selecting-specific-fields","content":" If we wish to limit the results to include only specific fields, we can pass the list of fields as a space-separated string in the second parameter to the find() method, ie:  Company.find({ companyName: 'The Kwik-E-Mart' }, 'address phone') //.sort({}) //optional &quot;sort&quot; - https://docs.mongodb.com/manual/reference/operator/aggregation/sort/ .exec() .then((companies) =&gt; { // companies will be an array of objects. // Each object will represent a document that matched the query console.log(companies); });   For complex queries (ie: &quot;greater than&quot;, &quot;in&quot;, &quot;or&quot;, etc, etc.) see the Mongoose Query Guide and the MongoDB documentation under Query and Projection Operators  ","version":"Next","tagName":"h3"},{"title":"Update​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/operations-crud-reference#update","content":" To update documents in the database, we use the updateOne() / updateMany() methods on the model object (ie: &quot;Company&quot;). We typically pass these function two arguments: the query to select which documents to update and the fields to set for the documents that match the query.  info See update operators, ie: $set, $push and $addToSet for more information.  Company.updateOne( { companyName: 'The Kwik-E-Mart' }, { $set: { employeeCount: 3 } }) .exec() .then(() =&gt; { // updated company console.log('updated company'); }) .catch((err) =&gt; { console.log(err); });   ","version":"Next","tagName":"h2"},{"title":"Delete​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/operations-crud-reference#delete","content":" To delete documents in the database, we use the deleteOne() / deleteMany() methods on the model object (ie: &quot;Company&quot;).  Company.deleteOne({ companyName: 'The Kwik-E-Mart' }) .exec() .then(() =&gt; { // removed company console.log('removed company'); }) .catch((err) =&gt; { console.log(err); });  ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/example-code","content":"Example Code You may download the sample code for this topic here: Relational-Database-Postgres","keywords":"","version":"Next"},{"title":"Introduction to Postgres","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/introduction-to-postgres","content":"","keywords":"","version":"Next"},{"title":"PostgreSQL (Postgres)​","type":1,"pageTitle":"Introduction to Postgres","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/introduction-to-postgres#postgresql-postgres","content":" From the PostgreSQL site, postgresql.org:  &quot;PostgreSQL (also known as &quot;Postgres&quot;) is a powerful, open source object-relational database system. It has more than 15 years of active development and a proven architecture that has earned it a strong reputation for reliability, data integrity, and correctness. It runs on all major operating systems, including Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, macOS, Solaris, Tru64), and Windows. It is fully ACID compliant, has full support for foreign keys, joins, views, triggers, and stored procedures (in multiple languages). It includes most SQL:2008 data types, including INTEGER, NUMERIC, BOOLEAN, CHAR, VARCHAR, DATE, INTERVAL, and TIMESTAMP. It also supports storage of binary large objects, including pictures, sounds, or video. It has native programming interfaces for C/C++, Java, .Net, Perl, Python, Ruby, Tcl, ODBC, among others, and exceptional documentation.  This is a great choice for us for multiple reasons; it is open source, highly available, standards compliant and most importantly, works nicely with node.js.  To get started, proceed to https://neon.tech and click on the &quot;Log in&quot; link at the top and log in with your GitHub account. Once you're logged in, follow the below steps to set up the database:  in the &quot;Get started with Neon for Free&quot; page, enter a value for project Name, ie: Seneca and Database Name, ie: SenecaDB (We can add more databases later) Leave &quot;region&quot; as the default value and Click the Create Project Button. At the next screen, you should see a dropdown with &quot;Connection String&quot; selected. Click this and choose Parameters only. Next, click the eye icon to reveal your password (NOTE Also consider checking the &quot;Pooled connection&quot; checkbox if this app will be deployed in a serverless environment, such as Vercel) Copy the PGHOST, PGDATABASE, PGUSER and PGPASSWORD values  ","version":"Next","tagName":"h2"},{"title":"pgAdmin​","type":1,"pageTitle":"Introduction to Postgres","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/introduction-to-postgres#pgadmin","content":" Now that we have our brand new Postgres database created in Neon.tech, why don't we try to connect to it using the most popular GUI tool for Postgres; pgAdmin. If you're following along from the lab room, it should already be installed. However, if you're configuring your home machine, you will need to download pgAdmin:  https://www.pgadmin.org/download/  Once it is installed and you have opened the app, we need to configure it to connect to our database:  Right Click on the &quot;Servers&quot; icon in the left pane (Under &quot;Browser&quot;) and select Create &gt; Server This will open the &quot;Create - Server&quot; Dialog window. Proceed to enter the following information about your Postgres Database on Neon.tech. Field\tValueName\tThis can be anything you like, ie &quot;Test Connection&quot; (Connection Tab) Host\tThis is the server for your Neon.tech Postgres DB (&quot;PGHOST&quot; value), ie: ab-cd-12345.us-east-2.aws.neon.tech (Connection Tab) Port\tThis is the port for your Neon.tech Postgres DB - it should be the same as what's already there, ie: 5432 (Connection Tab) Maintenance database\tEnter your &quot;PGDATABASE&quot; value here (Connection Tab) Username\tEnter your &quot;PGUSER&quot; value here (Connection Tab) Password\tEnter your &quot;PGPASSWORD&quot; value here Once you have entered all of your information, hit the &quot;Save&quot; button and click &quot;Servers&quot; in the left pane to expand your server connections. If you entered valid information for the above fields, you should see your Neon.tech Postgres DB Connection. Expand this item and the following &quot;Databases (2)&quot; item, and you should see your database. Expand this item, as well as the nested &quot;Schemas (1)&quot; item, followed by the &quot;public&quot; item, and you should be presented with something that looks like this:  Success! We will be keeping an eye on our data using this tool, so it is wise to have it running during development. ","version":"Next","tagName":"h2"},{"title":"Getting Started with Vercel","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide","content":"","keywords":"","version":"Next"},{"title":"Required Software​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide#required-software","content":" By now, you should have Node.js (available here) and Visual Studio Code (available here). However we will also need git To download git, proceed to this download page and download git for your operating system. Proceed to install git with the default settings. Once this is complete, you can verify that it is installed correctly by opening a command prompt / terminal and issuing the command git --version. This should output something like: git version 2.37.2 ( ... ). If it does not output the installed version of git, then something is wrong and it is not installed correctly. Lastly, for Vercel to gain access to our code, we must eventually place it on GitHub. Therefore, you must also have account on GitHub before proceeding.  ","version":"Next","tagName":"h2"},{"title":"Configuring your App for Vercel​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide#configuring-your-app-for-vercel","content":" Before we can start working with Vercel, we must make a few key changes to our code to ensure that it can be successfully deployed on Vercel. These include:  ","version":"Next","tagName":"h2"},{"title":"Adding a \"vercel.json\" file.​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide#adding-a-verceljson-file","content":" For our applications (defined in a &quot;server.js&quot; file), we must add the following &quot;vercel.json&quot; file to the root of our project:  { &quot;version&quot;: 2, &quot;builds&quot;: [ { &quot;src&quot;: &quot;server.js&quot;, &quot;use&quot;: &quot;@vercel/node&quot;, &quot;config&quot;: { &quot;includeFiles&quot;: [&quot;dist/**&quot;] } } ], &quot;routes&quot;: [ { &quot;src&quot;: &quot;/(.*)&quot;, &quot;dest&quot;: &quot;server.js&quot; } ] }   ","version":"Next","tagName":"h3"},{"title":"Setting the \"views\" Application Setting​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide#setting-the-views-application-setting","content":" If you are using a template engine in your application (ie: EJS), then you will need to add the line:  app.set('views', __dirname + '/views');   before your route definitions.  ","version":"Next","tagName":"h3"},{"title":"Updating your \"express.static()\" Middleware​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide#updating-your-expressstatic-middleware","content":" Similarly, if you are using the &quot;express.static()&quot; middleware to define a &quot;public&quot; folder, you must also include the &quot;__dirname&quot; in your path, ie:  app.use(express.static(__dirname + '/public'));   ","version":"Next","tagName":"h3"},{"title":"Explicitly Requiring the \"pg\" Module​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide#explicitly-requiring-the-pg-module","content":" If you are using Sequelize with the &quot;pg&quot; / &quot;pg-hstore&quot; modules, Vercel will give you an error if you do not explicitly require the &quot;pg&quot; module, ie:  require('pg'); // explicitly require the &quot;pg&quot; module const Sequelize = require('sequelize');   ","version":"Next","tagName":"h3"},{"title":"Committing Your Code​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide#committing-your-code","content":" Once you have configured your code for Vercel and you are ready to publish it, the next steps are to initialize a Git repository at the root of your project folder and push your code to GitHub:  First, issue the following command from the integrated terminal at the &quot;root&quot; folder of your project: git init - this will initialize a local git repository in your helloworld folder. Next, create a file called .gitignore containing the text: node_modules This will ensure that the node_modules folder does not get included in your local git repository Finally, click the &quot;Source Control&quot; icon in the left bar (it should have a blue dot next to it) and type &quot;initial commit&quot; for the message in the &quot;Message&quot; box. Once this is done, click the checkmark above the message box to commit your changes. caution If, at this point, you receive the error: &quot;Git: Failed to execute git&quot;, try executing the following commands in the integrated terminal: git config --global user.email &quot;you@example.com&quot; git config --global user.name &quot;Your Name&quot; Once this is complete, attempt to click the checkmark again to commit your changes.  ","version":"Next","tagName":"h2"},{"title":"Create a GitHub Repository​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide#create-a-github-repository","content":" For Vercel to gain access to our code, we must place it on GitHub. Therefore, the next step in this process is creating a GitHub repository for your code:  Sign in to your GitHub account. Find and click a &quot;+&quot; button on the Navigation Bar. Then, choose &quot;New Repository&quot; from the dropdown menu. Fill in the repository name text field with the name of your project. Also, please make sure that the &quot;Private&quot; option is selected: Once you're happy with the settings, hit the &quot;Create repository&quot; button.  ","version":"Next","tagName":"h3"},{"title":"Connect the Local Git Repository to GitHub​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide#connect-the-local-git-repository-to-github","content":" Now that our GitHub repository is created, we can proceed to update it with our local copy:  First, go to your newly-created GitHub repository and click the &quot;copy&quot; button in the &quot;Quick Setup&quot; block: This will copy the URL of your remote GitHub repository. Next, go back to your Terminal again and add this remote URL by running the following command: git remote add origin URL   where URL is the remote repository URL that you have copied in the previous step.  To confirm that &quot;origin&quot; was added correctly, run the command: git remote -v. You should see something like this: origin git@github.com:patrick-crawford/helloworld.git (fetch) origin git@github.com:patrick-crawford/helloworld.git (push) Finally, you can push the code from your local repository to the remote one using the command: git push origin master caution If at this point, you see the error: &quot;src refspec master does not match any&quot; then &quot;master&quot; is not set as your default branch. Execute the command git status to determine which branch you're on (it may be &quot;main&quot;) and push that instead, ie: git push origin main, for example  You can verify that the code was pushed by going back to your Browser and opening your GitHub repository.  ","version":"Next","tagName":"h3"},{"title":"Connect the GitHub Repository to Vercel​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide#connect-the-github-repository-to-vercel","content":" You should now be ready to push your code to Vercel. First, browse to https://vercel.com and hit the &quot;Start Deploying&quot; button.  Next, press the &quot;Continue with GitHub&quot; button, since our code is located on GitHub. If you are not currently logged in to GitHub, you will need to provide your credentials in a pop-up window before continuing. Once you have logged in to GitHub, you will be taken to the Let's build something new. screen in Vercel, which prompts you to &quot;Import Git Repository&quot;. From here, you will need to click &quot;+ Add GitHub Account&quot; This will prompt you to &quot;Install Vercel&quot;. Feel free to install it for &quot;All repositories&quot; You should now see your repository available for import. To proceed, click Import At the next page, you are not required to make any changes, as Vercel should detect that we are using Node.js. If you had any environment variables, you could set them here as well. Once you are done, click Deploy. Once the deploy step has completed, you should be taken to a &quot;Congratulations!&quot; page with a black button labeled Go To Dashboard. Click this to see the information about your deployment.  ","version":"Next","tagName":"h3"},{"title":"Make Changes and Push to GitHub​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide#make-changes-and-push-to-github","content":" Finally, our code is linked to Vercel via. GitHub!  You should now be able to make any changes you wish and trigger a redeploy of your server on Vercel by simply making changes locally, checking in your code using git and &quot;pushing&quot; it to GitHub, using the above instructions.  Good luck and Happy Coding!  ","version":"Next","tagName":"h3"},{"title":"Alternative (Render)​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingToolsAndFrameworks/Resources/vercel-guide#alternative-render","content":" Render, like Vercel, also has a free tier that is available without a credit card or separate account (you can use GitHub to sign in):  &quot;It’s easy to deploy a Web Service on Render. Link your GitHub or GitLab repository and click Create Web Service. Render automatically builds and deploys your service every time you push to your repository. Our platform has native support for Node.js, Python, Ruby, Elixir, Go, and Rust. If these don’t work for you, we can also build and deploy anything with a Dockerfile.&quot; https://render.com/docs/web-services.  Unfortunately, the main drawback of using the free services of Render is that our deployments (web services) are spun down after 15 minutes of inactivity. This will cause a significant delay in the response of the first request after a period of inactivity while the instance spins up.  For more information see the official documentation on &quot;Free Web Services&quot;.  To get started using Render, click the &quot;GET STARTED FOR FREE&quot; button on their main site. This will take you to a login page where you can use your GitHub account for authentication.  Once logged in, click the blue &quot;New +&quot; button in the top menu bar and choose &quot;Web Service&quot;. This will take you to a page where you can choose your GitHub repository for deployment. If you do not see your repository in the &quot;Connect a repository&quot; section, Click &quot;Configure account&quot; under the &quot;GitHub&quot; heading in the right sidebar. This will allow us to grant &quot;Render&quot; permission to all of our repositories (essentially performing the same task that was necessary for Vercel to access our repositories ).  Once this is complete and you can see your repository in the list, click the corresponding &quot;Connect&quot; button. You will then be taken to a screen where you must provide:  A unique name for your web serviceA &quot;start&quot; command (this will typically be &quot;node server.js&quot;, ie: the same &quot;start&quot; command that you will find in your package.json file)  Finally, ensure that the &quot;Free&quot; instance type is checked and click &quot;Create Web Service&quot; and wait for your code to build and deploy. ","version":"Next","tagName":"h2"},{"title":"Operations (CRUD) Reference","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/operations-crud-reference","content":"","keywords":"","version":"Next"},{"title":"Create​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/operations-crud-reference#create","content":" To create new names in our Name table, we can use the following code:  sequelize.sync().then(() =&gt; { Name.create({ fName: 'Kyler', lName: 'Odin', }).then(() =&gt; { console.log('Kyler Odin created'); }); Name.create({ fName: 'Grier', lName: 'Garrick', }).then(() =&gt; { console.log('Grier Garrick created'); }); Name.create({ fName: 'Kolby', lName: 'Greyson', }).then(() =&gt; { console.log('Kolby Greyson created'); }); });   In the above code we create three new objects following the fields defined in our &quot;Name&quot; model. Since our &quot;Name&quot; model is synchronized with the database, this adds three new records - each with their own unique &quot;id&quot; value, as well as &quot;createdAt&quot; and &quot;updatedAt&quot; values for the implicit primary key and timestamp columns. The create function automatically persists the new object to the database and since it also returns a promise, we can execute code after the operation is complete. In this case we simply output the name to the console.  ","version":"Next","tagName":"h2"},{"title":"Read​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/operations-crud-reference#read","content":" To read entries from our Name table, we can use the following code:  sequelize.sync().then(() =&gt; { // return all first names only Name.findAll({ attributes: ['fName'], }).then((data) =&gt; { console.log('All first names'); for (let i = 0; i &lt; data.length; i++) { console.log(data[i].fName); } }); // return all first names where id == 2 Name.findAll({ attributes: ['fName'], where: { id: 2, }, }).then((data) =&gt; { console.log('All first names where id == 2'); for (let i = 0; i &lt; data.length; i++) { console.log(data[i].fName); } }); });   Here, we are once again using a reference to our &quot;Name&quot; model. This time we are using it to fetch data from the &quot;Name&quot; table using the findAll() method. This method takes a number of configuration options in it's object parameter, such as attributes, which allows you to limit the columns that are returned (in this case we only want 'fName') and a where parameter that enables us to specify conditions that the data must meet to be returned. In the above example, id must have a value of 2.  caution It is important to note that trying to log a model instance directly to console.log (ie: console.log(data[i])) will produce a lot of clutter, since Sequelize instances have a lot of things attached to them. Instead, you can use the .toJSON() method (which automatically guarantees the instances to be JSON.stringify-ed well). See sequelize.org - logging instances for more information.  We can also specify an order that the returned data should be in, ie:  sequelize.sync().then(() =&gt; { // return all first names only Name.findAll({ order: ['fName'] }).then((data) =&gt; { console.log('All data'); for (let i = 0; i &lt; data.length; i++) { console.log(data[i].fName); } }); });   info See the documentation for advanced queries and fetching associated elements with the &quot;include&quot; option when using Model Relationships / Associations (ie: Task.findAll({include:[User]}) )  ","version":"Next","tagName":"h2"},{"title":"Update​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/operations-crud-reference#update","content":" To update existing names in our Name table, we can use the following code:  sequelize.sync().then(() =&gt; { // update User 2's last name to &quot;James&quot; // NOTE: this also updates the &quot;updatedAt field&quot; Name.update( { lName: 'James', }, { where: { id: 2 }, // only update user with id == 2 } ).then(() =&gt; { console.log('successfully updated user 2'); }); });   In order to &quot;update&quot; a record in the &quot;Name&quot; table, we make use of the update method. This method takes two parameters: an object that contains all of the properties and (updated) values for a record, and a second object that is used to specify options for the update - most importantly, the &quot;where&quot; property. The &quot;where&quot; property contains an object that is used to specify exactly which record should be updated. In this case, it is the row that has an id value of 2.  ","version":"Next","tagName":"h2"},{"title":"Delete​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/operations-crud-reference#delete","content":" To delete existing names in our Name table, we can use the following code:  sequelize.sync().then(() =&gt; { // remove User 3 from the database Name.destroy({ where: { id: 3 }, // only remove user with id == 3 }).then(() =&gt; { console.log('successfully removed user 3'); }); });   The delete functionality is actually achieved via a method called destroy. In this case, we invoke the destroy method on the model that contains the record that we wish to remove (ie, &quot;Name&quot;). It takes a single options object as it's only parameter and like the update function, the most important option is the &quot;where&quot; property. The &quot;where&quot; property contains an object that is used to specify exactly which record should be removed. In this case, it is the row that has an id value of 3. ","version":"Next","tagName":"h2"},{"title":"Mongoose ODM with MongoDB","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/mongoose-odm-with-mongodb","content":"","keywords":"","version":"Next"},{"title":"Mongoose Schemas​","type":1,"pageTitle":"Mongoose ODM with MongoDB","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/mongoose-odm-with-mongodb#mongoose-schemas","content":" Before we look at how to establish a connection to our MongoDB Atlas DB and work with the data using Mongoose, let's first determine the type of data that we wish to store. For example, let's say that our application requires &quot;company&quot; information to be persisted. Each &quot;company&quot; used by our system can be represented using the following properties (ie, its &quot;shape&quot;), as illustrated below for &quot;The Kwik-E-Mart&quot;:  { companyName: &quot;The Kwik-E-Mart&quot;, address: &quot;Springfield&quot;, phone: &quot;212-842-4923&quot;, employeeCount: 3, country: &quot;U.S.A&quot; }   To begin working with &quot;companies&quot; like this in our database using Mongoose, the first step is to create a &quot;schema&quot;.  ","version":"Next","tagName":"h2"},{"title":"Creating a Schema​","type":1,"pageTitle":"Mongoose ODM with MongoDB","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/mongoose-odm-with-mongodb#creating-a-schema","content":" From the documentation: &quot;Everything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection&quot;. So, for us to work with a specific collection in our MongoDB database, we must first define a &quot;schema&quot;, which defines the structure of the documents to be added to the collection (as well as to provide other features such as &quot;validators&quot;, etc.).  To represent the above company data as a Mongoose Schema, we can use the following code:  const mongoose = require('mongoose'); let Schema = mongoose.Schema; let companySchema = new Schema({ companyName: String, address: String, phone: String, employeeCount: { type: Number, default: 0, }, country: String, }); let Company = mongoose.model('companies', companySchema);   Essentially, a schema is like a blueprint for a document that will be saved in the DB. Here, we define the fields that can exist on a document for this collection, and setting their expected types, default values, and sometimes if they are required, or have an index on them.  In the above code, we have defined a Company schema with 5 properties as discussed, and set their types appropriately. The employee count is not just a simple number, we also want to include a default value of 0 of the count field is not supplied. Using defaults where it makes sense to have them is good practice.  The last line of code tells mongoose to register this schema (companySchema) as a model and connect it to the companies collection (Note: the &quot;companies&quot; collection will be automatically created if it doesn't exist yet). We can then use the Company variable to make queries against this collection and insert, update, or remove documents from the Company model.  ","version":"Next","tagName":"h3"},{"title":"Unique Index​","type":1,"pageTitle":"Mongoose ODM with MongoDB","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/mongoose-odm-with-mongodb#unique-index","content":" A unique index may also be applied at the database level and can be attached to one or more fields of a document.  The most common use for this is when we want to enforce a unique value across all documents in a collection for a certain field. A perfect use case for this is the companyName field of our company schema, ie: it wouldn't make sense to have multiple companies with the same name in the system. To prevent this and add a unique index in to the companyName field, we just have to add unique: true to the schema declaration from before.  // define the company schema const companySchema = new Schema({ companyName: { type: String, unique: true, }, address: String, phone: String, employeeCount: { type: Number, default: 0, }, country: String, });   info With the &quot;unique: true&quot; property set on the &quot;companyName&quot; field, Mongoose will return &quot;E11000 duplicate key error&quot; if we try to save two companies with the same &quot;companyName&quot; field.  ","version":"Next","tagName":"h3"},{"title":"Adding Data​","type":1,"pageTitle":"Mongoose ODM with MongoDB","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/mongoose-odm-with-mongodb#adding-data","content":" Now that we have determined the &quot;schema&quot;, let's see how Mongoose works to add our data (&quot;The Kwik-E-Mart&quot;) to the database.  caution For the below code to function correctly, you will need to place your connection string (determined earlier in Introduction to MongoDB), in place of the 'Your connection string here'. You will also have to update it to include a database name. For example, if your connection string looks like the following: mongodb+srv://user:yourPassword@cluster0.abc123.mongodb.net/?retryWrites=true&amp;w=majority You must update it to include a database name so that the default name: &quot;test&quot; is not used. For example, if you wish your database to be called &quot;demo&quot;, you would update the connection string to include &quot;demo&quot; after &quot;mongodb.net/&quot;, ie: mongodb+srv://user:yourPassword@cluster0.abc123.mongodb.net/demo?retryWrites=true&amp;w=majority   // require mongoose and setup the Schema const mongoose = require('mongoose'); let Schema = mongoose.Schema; // connect to Your MongoDB Atlas Database mongoose.connect('Your connection string here'); // define the company schema let companySchema = new Schema({ companyName: String, address: String, phone: String, employeeCount: { type: Number, default: 0, }, country: String, }); // register the Company model using the companySchema // use the companies collection in the db to store documents let Company = mongoose.model('companies', companySchema); // create a new company let kwikEMart = new Company({ companyName: 'The Kwik-E-Mart', address: 'Springfield', phone: '212-842-4923', employeeCount: 3, country: 'U.S.A', }); // save the company kwikEMart .save() .then(() =&gt; { console.log('The Kwik-E-Mart company was saved to the companies collection'); process.exit(); }) .catch((err) =&gt; { console.log('There was an error saving the Kwik-E-Mart company'); process.exit(); });   ","version":"Next","tagName":"h2"},{"title":"Reading Data​","type":1,"pageTitle":"Mongoose ODM with MongoDB","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/mongoose-odm-with-mongodb#reading-data","content":" To confirm that our data was indeed added to the database, we can either log back in to MongoDB Atlas and click &quot;Browse collections&quot; for our cluster:    or we can query the data using Mongoose to confirm that it was entered correctly. Here, we will use the same code as above (being sure to include the code to create the &quot;Company&quot; object), except we can omit creating &amp; saving a new &quot;Company&quot; (ie: &quot;kwikEMart&quot;). Instead, we will use the &quot;find&quot; method on the &quot;Company&quot; model to locate our &quot;The Kwik-E-Mart&quot; company:  Company.find({ companyName: 'The Kwik-E-Mart' }) .exec() .then((company) =&gt; { if (!company) { console.log('No company could be found'); } else { console.log(company); } // exit the program after saving and finding process.exit(); }) .catch((err) =&gt; { console.log(`There was an error: ${err}`); process.exit(); });   info If you examine the output, you will notice that the data returned includes two extra fields, added by default to our document: _id: A unique ObjectID__v: The versionKey  ","version":"Next","tagName":"h2"},{"title":".exec()​","type":1,"pageTitle":"Mongoose ODM with MongoDB","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/mongoose-odm-with-mongodb#exec","content":" The .exec() call is added after a mongoose query to tell mongoose to return a promise. If you leave out the .exec(), mongoose will still work with .then() calls but the object returned will not be a proper promise. It is good practice to always use .exec() after your query has been setup and before the .then() method is invoked.  ","version":"Next","tagName":"h3"},{"title":"Arrays and Recursive Schemas​","type":1,"pageTitle":"Mongoose ODM with MongoDB","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/mongoose-odm-with-mongodb#arrays-and-recursive-schemas","content":" A &quot;recursive schema&quot; is a schema that contains an array of elements with the same schema as the definition. We can use this to store tree structures such as file / folder hierarchies or comment trees for a blog post. For example: say we wish to store a tree of comments, where each comment can have one or more comments, which can have one or more comments, and so on. We can specify our recursive &quot;commentSchema&quot; using the following code:  const commentSchema = new Schema({ comment: String, author: String, date: Date, }); commentSchema.add({ comments: [commentSchema] }); let Comment = mongoose.model('comments', commentSchema);   Here, we add a &quot;comments&quot; field with a type of &quot;[commentSchema]&quot; to the original &quot;commentSchema&quot;. Using this syntax, we indicate that all &quot;comments&quot; will consist of an Array defined by &quot;commentSchema&quot;. Now, we can easily create documents that appear in this format, ie:  let commentChain = new Comment({ comment: 'Star Wars is awesome', author: 'Author 1', date: new Date(), comments: [ { comment: 'I agree', author: 'Author 2', date: new Date(), comments: [ { comment: 'I agree with Author 2', author: 'Author 3', date: new Date(), comments: [], }, ], }, ], });   ","version":"Next","tagName":"h2"},{"title":"Multiple Connections​","type":1,"pageTitle":"Mongoose ODM with MongoDB","url":"/WebProgrammingToolsAndFrameworks/NoSQL-Database-MongoDB/mongoose-odm-with-mongodb#multiple-connections","content":" Using Mongoose, it is also possible to have multiple connections configured for your application. If this is the case, we have to make a few small changes on how we connect to each DB, and how we define our models  caution The use of the &quot;encodeURIComponent&quot; is necessary if your password contains special characters, ie &quot;$&quot;  // ... let pass1 = encodeURIComponent('pa$$word1'); // this step is needed if there are special characters in your password, ie &quot;$&quot; let db1 = mongoose.createConnection( `mongodb+srv://user:${pass1}@cluster0.abc123.mongodb.net/demo?retryWrites=true&amp;w=majority` ); // verify the db1 connection db1.on('error', (err) =&gt; { console.log('db1 error!'); }); db1.once('open', () =&gt; { console.log('db1 success!'); }); // ... let pass2 = encodeURIComponent('pa$$word2'); // this step is needed if there are special characters in your password, ie &quot;$&quot; let db2 = mongoose.createConnection( `mongodb+srv://dbUser:${pass2}@cluster0.2def3.mongodb.net/db2?retryWrites=true&amp;w=majority` ); // ... let model1 = db1.model('model1', model1Schema); // predefined &quot;model1Schema&quot; used to create &quot;model1&quot; on db1 let model2 = db2.model('model2', model2Schema); // predefined &quot;model2Schema&quot; used to create &quot;model2&quot; on db2 // ...   Instead of using &quot;connect&quot;, we instead use &quot;createConnection&quot; and save the result as a reference to the connection (ie: &quot;db1&quot; and &quot;db2&quot; from above). We can then use db1 or db2 to create models on each database separately. Additionally, if we want to test the connection, we can use the .on() and .once() methods of each connection. ","version":"Next","tagName":"h2"},{"title":"Sequelize ORM with Postgres","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/sequelize-orm-with-postgres","content":"","keywords":"","version":"Next"},{"title":"Getting Started​","type":1,"pageTitle":"Sequelize ORM with Postgres","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/sequelize-orm-with-postgres#getting-started","content":" Fortunately, &quot;Sequelize&quot; is packaged as a module on NPM (see: &quot;sequelize&quot;). Therefore to get started, we will need to &quot;install&quot; it as a dependency within our project. With your application folder open in Visual Studio Code, open the integrated terminal and enter the command  npm install sequelize pg pg-hstore   This will add both the sequelize and the pg / pg-hstore modules to our node_modules folder, as well as add their names &amp; version numbers to our package.json file under &quot;dependencies&quot;.  Next, we need to update our server.js file to use the new modules so that we can test our connection to the database. If you're working with an existing application, comment out any existing Express app code (routes, listen, etc.) that you have in server.js (for the time being) and add the following code:  const Sequelize = require('sequelize'); // set up sequelize to point to our postgres database const sequelize = new Sequelize('database', 'user', 'password', { host: 'host', dialect: 'postgres', port: 5432, dialectOptions: { ssl: { rejectUnauthorized: false }, }, }); sequelize .authenticate() .then(() =&gt; { console.log('Connection has been established successfully.'); }) .catch((err) =&gt; { console.log('Unable to connect to the database:', err); });   Where database is your &quot;PGDATABASE&quot; value, user is your &quot;PGUSER&quot; value, password is your &quot;PGPASSWORD&quot; and lastly, host will be your &quot;PGHOST&quot; url (ie: &quot;ab-cd-12345.us-east-2.aws.neon.tech&quot;).  Once you have updated your app to use the Sequelize module, try running it using our usual &quot;node server.js&quot; command. If everything was entered correctly, you should see the following message in the console:  Executing (default): SELECT 1+1 AS result Connection has been established successfully.   Finally, If you see any other errors at this point, go back and check that you have entered all of your credentials correctly when creating the sequelize object. Recall: You can use ctrl + c to stop a node.js application from running.  ","version":"Next","tagName":"h2"},{"title":"Models (Tables) Introduction​","type":1,"pageTitle":"Sequelize ORM with Postgres","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/sequelize-orm-with-postgres#models-tables-introduction","content":" Now that we have successfully tested the connection to our Postgres database from our node.js application, we must discuss what the Sequelize module does and how we will be using it to manage data persistence within our Postgres Database.  As we know, sequelize is technically an Object-Relational Mapping (&quot;ORM&quot;) framework. It maps our JavaScript objects (&quot;models&quot;) to tables and rows within our database and will automatically execute relevant SQL commands on the database whenever data using our &quot;models&quot; (JavaScript objects) is updated. This saves us the trouble of manually writing complex SQL statements whenever we wish to update the back-end database to reflect changes made by the user.  To see this in action, update your server.js file to use the following code:  const Sequelize = require('sequelize'); // set up sequelize to point to our postgres database const sequelize = new Sequelize('database', 'user', 'password', { host: 'host', dialect: 'postgres', port: 5432, dialectOptions: { ssl: { rejectUnauthorized: false }, }, }); // Define a &quot;Project&quot; model const Project = sequelize.define('Project', { title: Sequelize.STRING, description: Sequelize.TEXT, }); // synchronize the Database with our models and automatically add the // table if it does not exist sequelize.sync().then(() =&gt; { // create a new &quot;Project&quot; and add it to the database Project.create({ title: 'Project1', description: 'First Project', }) .then((project) =&gt; { // you can now access the newly created Project via the variable project console.log('success!'); }) .catch((error) =&gt; { console.log('something went wrong!'); }); });   Once again, database is your randomly generated “User &amp; Default database” value, user is also your randomly generated “User &amp; Default database” value, password is your password and lastly, host will be your server host url.  There is a lot going on in the above code - but before we walk through what everything is doing, try updating the above code with your database credentials and run it once again with node server.js. You should see the something very similar to the following output:  Executing (default): INSERT INTO &quot;Projects&quot; (&quot;id&quot;,&quot;title&quot;,&quot;description&quot;,&quot;createdAt&quot;,&quot;updatedAt&quot;) VALUES (DEFAULT,'Project1','First Project','2017-02-28 22:45:25.163 +00:00','2017-02-28 22:45:25.163 +00:00') RETURNING \\*; success!   It appears that Sequelize has done some of the heavy lifting for us. To confirm that the create operation was successful and that we have indeed persisted &quot;Project1&quot; in a new &quot;Projects&quot; table, go back to your pgAdmin application, right-click on &quot;Tables&quot; and choose &quot;Refresh&quot;. You should now see our new &quot;Projects&quot; table in the list.  To view the contents of the table, right-click on the &quot;Projects&quot; table and select View / Edit Data &gt; All Rows. This will open a new window with a grid view that you can use to explore the data in the table:    You will notice that there are some columns in the &quot;Project&quot; table that we didn't define in our &quot;Project&quot; Model; specifically: id, createdAt and updatedAt; recall:  // Define a &quot;Project&quot; model const Project = sequelize.define('Project', { title: Sequelize.STRING, description: Sequelize.TEXT, });   It follows that the title and description columns are there, but where did the others come from? The addition of the extra columns are actually added by default by the sequelize module. Whenever we &quot;define&quot; a new model, we automatically get id, createdAt and updatedAt and when we save data using this model, our data is automatically updated to include correct values for those fields. This is extremely handy, as we didn't actually create our primary-key for the table (sequelize went ahead and made &quot;id&quot; our primary key). Also, the createdAt and updatedAt fields are both widely used. However, if we decide that we want to specify our own auto-incrementing primary key and remove the createdAt and updatedAt fields, we can define our model using the following code instead:  // Define a &quot;Project&quot; model const Project = sequelize.define( 'Project', { project_id: { type: Sequelize.INTEGER, primaryKey: true, // use &quot;project_id&quot; as a primary key autoIncrement: true, // automatically increment the value }, title: Sequelize.STRING, description: Sequelize.TEXT, }, { createdAt: false, // disable createdAt updatedAt: false, // disable updatedAt } );   Now that we have defined our Project model (either with or without the &quot;createdAt&quot; and &quot;updatedAt&quot; timestamps) we can look at the rest of the code, ie the sync() operation and creating Project1 - recall:  // synchronize the Database with our models and automatically add the // table if it does not exist sequelize.sync().then(() =&gt; { // create a new &quot;Project&quot; and add it to the database Project.create({ title: 'Project1', description: 'First Project', }) .then((project) =&gt; { // you can now access the newly created Project via the variable project console.log('success!'); }) .catch((error) =&gt; { console.log('something went wrong!'); }); });   The sequelize.sync() operation needs to be completed before we can do anything else. This ensures that all of our models are represented in the database as tables. If we have defined a model in our code that doesn't correspond to a table in the database, sequelize.sync() will automatically create it (as we have seen).  info We do not have to sync() the database before every operation. This is only required when the server starts to ensure that the models are correctly represented as tables within the database.  Once our models have been successfully sync()'d with the database, we can start working with the data. You will notice that we use the familiar then() and catch() functions; this is because both sync() and create() return a promise and as we stated above, we must work with the data after the sync() operation has successfully completed.  If sync() resolves successfully, we then wish to create a new record in the &quot;Project&quot; table, so we use Project.create() method and pass it some data (title and description). If the operation completed successfully, we see the message &quot;success!&quot; in the console - otherwise we catch the error and output &quot;something went wrong!&quot;  ","version":"Next","tagName":"h2"},{"title":"Defining Models​","type":1,"pageTitle":"Sequelize ORM with Postgres","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/sequelize-orm-with-postgres#defining-models","content":" One of the most important things we must do when working with Sequelize is to correctly set up our models. Once the models are set up successfully, working with the data is simple. Since each model technically corresponds to a table within our database, what we are really doing is defining tables. Each column of a table within our database stores a specific type of data. In our previous example, we define the column title as a STRING and the column description as TEXT within a table called Project.  Sequelize provides definitions for a full list of types, and each column is given a type. The following is a list of the most common types:  Sequelize.STRING - A variable length string. Default length 255Sequelize.TEXT - An unlimited length text column.Sequelize.INTEGER - A 32 bit integer.Sequelize.FLOAT - Floating point number (4-byte precision).Sequelize.DOUBLE - Floating point number (8-byte precision)Sequelize.DATE - A datetime columnSequelize.TIME - A time columnSequelize.BOOLEAN - A boolean column  So, if we want to define a model (table) that stores blog entries, we could use the following code:  // Define a &quot;BlogEntry&quot; model const BlogEntry = sequelize.define('BlogEntry', { title: Sequelize.STRING, // entry title author: Sequelize.STRING, // author of the entry entry: Sequelize.TEXT, // main text for the entry views: Sequelize.INTEGER, // number of views postDate: Sequelize.DATE, // Date the entry was posted });   info It is also possible to introduce data validation when we define our models. For a full list of available rules and how they're implemented, see: Validators in the official documentation.  ","version":"Next","tagName":"h2"},{"title":"Model Relationships / Associations​","type":1,"pageTitle":"Sequelize ORM with Postgres","url":"/WebProgrammingToolsAndFrameworks/Relational-Database-Postgres/sequelize-orm-with-postgres#model-relationships--associations","content":" In a relational database system, tables (models) can be related using foreign key relationships / associations. For example, say we have a table of Users and a table of Tasks, where each User could have 1 or more Tasks. To enforce this relationship, we would add an additional column on the Tasks table as a foreign-key to the Users table, since 1 or more Tasks could belong to a specific user. For example, &quot;Task 1&quot;, &quot;Task 2&quot; and &quot;Task 3&quot; could all belong to &quot;User 1&quot;, whereas &quot;Task 4&quot; and &quot;Task 5&quot; may belong to &quot;User 2&quot;.  Using Sequelize models, we can easily define this relationship using the hasMany() / belongsTo() methods (since &quot;User has many Task(s)&quot;), for example:  // Define our &quot;User&quot; and &quot;Task&quot; models const User = sequelize.define('User', { fullName: Sequelize.STRING, // the user's full name (ie: &quot;Jason Bourne&quot;) title: Sequelize.STRING, // the user's title within the project (ie, developer) }); const Task = sequelize.define('Task', { title: Sequelize.STRING, // title of the task description: Sequelize.TEXT, // main text for the task }); // Associate Task with User &amp; automatically create a foreign key // relationship on &quot;Task&quot; via an automatically generated &quot;UserId&quot; field Task.belongsTo(User);   If we wish to create a User and then assign him some tasks, we can &quot;create&quot; the tasks immediately after the user is created, ie:  sequelize.sync().then(() =&gt; { // Create user &quot;Jason Bourne&quot; User.create({ fullName: 'Jason Bourne', title: 'developer', }).then((user) =&gt; { console.log('user created'); // Create &quot;Task 1&quot; for the new user Task.create({ title: 'Task 1', description: 'Task 1 description', UserId: user.id, // set the correct Userid foreign key }).then(() =&gt; { console.log('Task 1 created'); }); // Create &quot;Task 2&quot; for the new user Task.create({ title: 'Task 2', description: 'Task 2 description', UserId: user.id, // set the correct Userid foreign key }).then(() =&gt; { console.log('Task 2 created'); }); }); });   Next, try running this code and take a look at your database in pgAdmin. You should see that two new tables, &quot;Users&quot; and &quot;Tasks&quot; have been created, with &quot;Jason Bourne&quot; inside the &quot;User&quot; table and &quot;Task 1&quot; and &quot;Task 2&quot; inside the &quot;Task&quot; table. The two new tasks will both have a UserId matching &quot;Jason Bourne&quot;'s id. We have achieved the one-to-many relationship between this user and his tasks.  info Sequelize also supports other types of relationships using: hasOne()belongsToMany() For more information, refer to &quot;Associations&quot; in the official documentation. ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/example-code","content":"Example Code You may download the sample code for this topic here: Security-Considerations","keywords":"","version":"Next"},{"title":"HTTPS Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/https-introduction","content":"","keywords":"","version":"Next"},{"title":"Digital Certificates​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/https-introduction#digital-certificates","content":" HTTPS uses a protocol known as &quot;TLS&quot; (formerly &quot;SSL&quot; or &quot;Secure Sockets Layer&quot;) to enable secure communication across a network in order to prevent tampering / eavesdropping. This is achieved through the use of something called a &quot;digital certificate&quot;:  Digital Certificates have a key pair: a public and a private key. These keys work together to establish an encrypted connection. The certificate also contains what is called the “subject,” which is the identity of the certificate/website owner. The most important part of a certificate is that it is digitally signed by a trusted CA (&quot;Certificate Authority&quot;), like DigiCert. Anyone can create a certificate, but browsers only trust certificates that come from an organization on their list of trusted CAs. Browsers come with a pre-installed list of trusted CAs, known as the Trusted Root CA store. In order to be added to the Trusted Root CA store and thus become a Certificate Authority, a company must comply with and be audited against security and authentication standards established by the browsers. https://www.digicert.com  Essentially, for a website / app to use HTTPS, a certificate from a trusted source (such as &quot;Digicert&quot;) is required. This certificate contains a &quot;digital signature&quot;, signed by the Certificate Authority (ie: &quot;Digicert&quot;) which proves the validity of the certificate and the website. It also contains a public / private key pair, enabling messages to be encrypted using a public key, but only read using the corresponding private key. Encrypting messages using a trusted website's public key is the first step to enabling two way encrypted communication:  When a web browser (or client) directs to a secured website, the website server shares its TLS/SSL certificate and its public key with the client to establish a secure connection and a unique session key. The browser confirms that it recognizes and trusts the issuer, or Certificate Authority, of the SSL certificate—in this case DigiCert. The browser also checks to ensure the TLS/SSL certificate is unexpired, unrevoked, and that it can be trusted. The browser sends back a symmetric session key and the server decrypts the symmetric session key using its private key. The server then sends back an acknowledgement encrypted with the session key to start the encrypted session. Server and browser now encrypt all transmitted data with the session key. They begin a secure session that protects message privacy, message integrity, and server security.  ","version":"Next","tagName":"h2"},{"title":"Viewing Certificates​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/https-introduction#viewing-certificates","content":" Information about a website's digital certificate can be easily viewed in a modern web browser. Typically, to the left of the URL bar, you will find a &quot;lock&quot; icon. Click on it to view information about your connection with this website (screenshot taken in Chrome).    Notice how it shows that the site is using a secure connection with an option to &quot;Show Connection Details&quot;. Clicking this allows us to confirm that the certificate is indeed valid and was issued by &quot;DigiCert Inc&quot;.    We may also switch to the &quot;Details&quot; pane, which provides information about the certificate, such as the issuer, expiration date, and the encryption algorithms used.  With this information, we can confirm that sending login credentials and retrieving banking information from CIBC is achieved using encrypted packets between the web browser and server. Anyone who might capture them in transit would not be able to obtain any useful information.  ","version":"Next","tagName":"h3"},{"title":"Self Signed Certificates​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/https-introduction#self-signed-certificates","content":" SSL/TLS certificates can be created on your own and technically they can be used, however it is important to note that these certificates should not be used in a production environment. This is because using your own &quot;self signed&quot; certificates will result in a warning from the browser that your website is using an &quot;untrusted&quot; certificate, since it did not come from a trusted CA.  ","version":"Next","tagName":"h2"},{"title":"Creating Self Signed Certificates (Development)​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/https-introduction#creating-self-signed-certificates-development","content":" When testing HTTPS locally and during development, it is common to use a self signed certificate. We can generate them in the terminal using the following command:  openssl req -new -x509 -nodes -out server.crt -keyout server.key   This will initiate the following prompts for information about the organization the certificate will be issued to. The only important one for now is the Common Name - this must be localhost (ie: the domain the certificate will be valid for), since we will be running our server locally:  Generating a 2048 bit RSA private key .............................+++ ...+++ writing new private key to 'server.key' ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) []:CA State or Province Name (full name) []:ON Locality Name (eg, city) []:Toronto Organization Name (eg, company) []:ACME Widgets Organizational Unit Name (eg, section) []:IT Dept Common Name (e.g. server FQDN or YOUR name) []:localhost Email Address []:   This should generate two files: &quot;server.crt&quot; and &quot;server.key:  ","version":"Next","tagName":"h3"},{"title":"Using SSL Certificates​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/https-introduction#using-ssl-certificates","content":" Now that we have the required files (ie: &quot;server.crt&quot; and &quot;server.key&quot;), we can begin to configure our &quot;server.js&quot; code to start listening for both HTTP and HTTPS connections:  const fs = require('fs'); const http = require('http'); const https = require('https'); const express = require('express'); const app = express(); const HTTP_PORT = process.env.PORT || 8080; const HTTPS_PORT = 4433; app.get('/', (req, res) =&gt; { res.send('Hello World'); }); // read in the contents of the HTTPS certificate and key const https_options = { key: fs.readFileSync(__dirname + '/server.key'), cert: fs.readFileSync(__dirname + '/server.crt'), }; // listen on ports HTTP_PORT and HTTPS_PORT. http.createServer(app).listen(HTTP_PORT, () =&gt; { console.log(`http server listening on: ${HTTP_PORT}`); }); https.createServer(https_options, app).listen(HTTPS_PORT, () =&gt; { console.log(`https server listening on: ${HTTPS_PORT}`); });   You will notice that a few key changes have been made to our usual &quot;simple web server&quot;. Primarily:  We import both the &quot;http&quot; and &quot;https&quot; modules, as well as the &quot;fs&quot; module (to read the .crt and .key files) Use createServer() method for both &quot;http&quot; and &quot;https&quot;, making sure to provide the values for both the key and cert for the &quot;https_options&quot; parameter when using &quot;https&quot;  Finally, start the server and navigate to: https://localhost:4433  Depending on your web browser, you may observe a security warning if the system is functioning correctly. If you get this warning (with &quot;Advanced&quot; selected) everything is working as intended so far.  ","version":"Next","tagName":"h2"},{"title":"Warning in Firefox​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/https-introduction#warning-in-firefox","content":"   ","version":"Next","tagName":"h3"},{"title":"Warning in Chrome​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/https-introduction#warning-in-chrome","content":"   caution If you do not see the option to &quot;Proceed to localhost&quot;, then typing &quot;thisisunsafe&quot; will allow you to proceed.  Accept the warnings to add an exemption and proceed to the page. ","version":"Next","tagName":"h3"},{"title":"Secure HTTP Headers","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/secure-http-headers","content":"","keywords":"","version":"Next"},{"title":"Introducing Helmet.js​","type":1,"pageTitle":"Secure HTTP Headers","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/secure-http-headers#introducing-helmetjs","content":" To help us work with these secure headers, we can use an NPM module called &quot;helmet.js&quot;. Helmet.js functions as middleware in our Node / Express.js applications that automatically sets or removes certain response headers in an effort to enhance security.  To get started using helmet, we must install it from NPM and require it in our server.js code:  npm install helmet   const helmet = require('helmet');   Once it is required, we can use the default configuration by simply invoking it an &quot;app.use()&quot; to register it as middleware, ie:  app.use(helmet());   If you test an express server (ie: our &quot;simple web server&quot;) with this configuration, you should see a similar set of headers have been automatically added to the response:  Response Header\tValueContent-Security-Policy\tdefault-src 'self';base-uri 'self';font-src 'self' https: data:;form-action 'self';frame-ancestors 'self';img-src 'self' data:;object-src 'none';script-src 'self';script-src-attr 'none';style-src 'self' https: 'unsafe-inline';upgrade-insecure-requests Cross-Origin-Opener-Policy\tsame-origin Cross-Origin-Resource-Policy\tsame-origin Origin-Agent-Cluster\t?1 Referrer-Policy\tno-referrer X-Content-Type-Options\tnosniff X-Dns-Prefetch-Control\toff X-Download-Options\tnoopen X-Frame-Options\tSAMEORIGIN X-Permitted-Cross-Domain-Policies\tnone X-Xss-Protection\t0  Additionally, the X-Powered-By header has also been removed.  For configuration options, see the &quot;official Helmet.js documentation&quot; ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/example-code","content":"Example Code You may download the sample code for this topic here: Template-Engines","keywords":"","version":"Next"},{"title":"Password Encryption","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/password-encryption","content":"","keywords":"","version":"Next"},{"title":"Bcrypt​","type":1,"pageTitle":"Password Encryption","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/password-encryption#bcrypt","content":" A famous encryption algorithm to achieve &quot;one-way&quot; encryption, is &quot;bcrypt&quot;  bcrypt is a password-hashing function designed by Niels Provos and David Mazières, based on the Blowfish cipher and presented at USENIX in 1999. Besides incorporating a salt to protect against rainbow table attacks, bcrypt is an adaptive function: over time, the iteration count can be increased to make it slower, so it remains resistant to brute-force search attacks even with increasing computation power. https://en.wikipedia.org/wiki/Bcrypt  This sounds like exactly what we need. Fortunately, bcrypt is available on NPM via a module called: &quot;bcrypt.js&quot;.  npm install bcryptjs   const bcrypt = require('bcryptjs');   ","version":"Next","tagName":"h2"},{"title":"Encrypting Passwords​","type":1,"pageTitle":"Password Encryption","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/password-encryption#encrypting-passwords","content":" If we wish to encrypt a plain text password (ie: &quot;myPassword123&quot;), we can use bcrypt to generate a &quot;salt&quot; and &quot;hash&quot; the text:  // Encrypt the plain text: &quot;myPassword123&quot; bcrypt .hash('myPassword123', 10) .then((hash) =&gt; { // Hash the password using a Salt that was generated using 10 rounds // TODO: Store the resulting &quot;hash&quot; value in the DB }) .catch((err) =&gt; { console.log(err); // Show any errors that occurred during the process });   ","version":"Next","tagName":"h3"},{"title":"Validating Encrypted Passwords​","type":1,"pageTitle":"Password Encryption","url":"/WebProgrammingToolsAndFrameworks/Security-Considerations/password-encryption#validating-encrypted-passwords","content":" If we wish to compare the &quot;hashed&quot; text with plain text (to see if a user-entered password matches the value in the DB), we use:  // Pull the password &quot;hash&quot; value from the DB and compare it to &quot;myPassword123&quot; (match) bcrypt.compare('myPassword123', hash).then((result) =&gt; { // result === true }); // Pull the password &quot;hash&quot; value from the DB and compare it to &quot;myPasswordABC&quot; (does not match) bcrypt.compare('myPasswordABC', hash).then((result) =&gt; { // result === false });  ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/example-code","content":"Example Code You may download the sample code for this topic here: UI-Toolkits","keywords":"","version":"Next"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/introduction","content":"","keywords":"","version":"Next"},{"title":"Returning HTML & Data​","type":1,"pageTitle":"Introduction","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/introduction#returning-html--data","content":" If we want to return a valid HTML5 page to the client that actually references data stored on the server, one solution would be to build a string that contains both HTML code and data, ie:  app.get('/viewData', function (req, res) { let someData = { name: 'John', age: 23, occupation: 'developer', company: 'Scotiabank', }; let htmlString = `&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;View Data&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border='1'&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;th&gt;Occupation&lt;/th&gt; &lt;th&gt;Company&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;${someData.name}&lt;/td&gt; &lt;td&gt;${someData.age}&lt;/td&gt; &lt;td&gt;${someData.occupation}&lt;/td&gt; &lt;td&gt;${someData.company}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt;`; res.send(htmlString); });   While this will work to send a valid HTML5 page containing our data back to the client, it's clearly not the best way to approach this problem. What if we had a complex page that contains data in different places throughout the layout? We would be building out an enormous string containing normal, static html and in a few places, inserting a reference to our data (someData object). Wouldn't it be better if we could just write a normal HTML document that references the data, instead of having to build one huge string for the whole page?  ","version":"Next","tagName":"h2"},{"title":"Template Engines​","type":1,"pageTitle":"Introduction","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/introduction#template-engines","content":" Fortunately, we can leverage &quot;template engines&quot; with Express to solve this exact problem. From the express.js documentation:  A template engine enables you to use static template files in your application. At runtime, the template engine replaces variables in a template file with actual values, and transforms the template into an HTML file sent to the client. This approach makes it easier to design an HTML page.  This sounds like exactly what we need and there are a number of popular options that we can choose from, such as:  &quot;Pug&quot;&quot;Express Handlebars&quot;&quot;EJS&quot;  In the next section, we will take a look at &quot;EJS&quot;:  A simple templating language that lets you generate HTML markup with plain JavaScript. No religiousness about how to organize things. No reinvention of iteration and control-flow. It's just plain JavaScript. ","version":"Next","tagName":"h2"},{"title":"EJS (Embedded JavaScript Templates)","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/ejs-embedded-javaScript-templates","content":"","keywords":"","version":"Next"},{"title":"Getting Started​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/ejs-embedded-javaScript-templates#getting-started","content":" To begin, create the following file in your “views” directory and name it “viewData.ejs”:  &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;View Data&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;th&gt;Occupation&lt;/th&gt; &lt;th&gt;Company&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;%= data.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data.age %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data.occupation %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data.company %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt;   This is a much cleaner approach. We no longer have to generate the full page as a string within our “/viewData” route and most importantly, all of the view logic (HTML) is separate from our control logic (routing).  In order to set this up correctly and get express to understand the file above, we need to modify our server code slightly:  The first thing that we need to do is download / install the EJS package using NPM. Open a terminal in Visual Studio Code (ctrl + ` or View -&gt; Integrated Terminal) and make sure that your working directory is somewhere within your project and run the command npm install ejs This will install the &quot;ejs&quot; package in the same way that we installed the &quot;express&quot; package and update the dependencies in our package.json file: &quot;dependencies&quot;: { &quot;ejs&quot;: ..., &quot;express&quot;: ...&quot; } Next, our server needs to know how to handle HTML files that are formatted using ejs, so near the top of our code (after we define our &quot;app&quot;), add the line: app.set('view engine', 'ejs'); This will tell our server that any file with the &quot;.ejs&quot; extension (instead of &quot;.html&quot;) will use the EJS &quot;engine&quot; (template engine). The final step involves updating our &quot;/viewData&quot; route to &quot;render&quot; our EJS file with the data: app.get('/viewData', function (req, res) { let someData = { name: 'John', age: 23, occupation: 'developer', company: 'Scotiabank', }; res.render('viewData', { data: someData, }); });   Now, the route no longer returns a string consisting of our HTML + data using res.send(), but instead invokes the render method on the response object (res). We pass the name of our new file without the extension (ie: &quot;viewData&quot; instead of &quot;viewData.ejs&quot;), and a &quot;data&quot; object to hold all of our data (someData).  ","version":"Next","tagName":"h2"},{"title":"EJS Syntax​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/ejs-embedded-javaScript-templates#ejs-syntax","content":" Before we begin to discuss the more advanced features of EJS, we must first become familiar with the syntax. For example, we have seen that &lt;%= ... %&gt; is used to render a specific value within our template. However, we should understand that this delimiter (&quot;tag&quot;), also escapes any HTML contained in the value (ie: &quot;&lt;br /&gt;&quot; will be rendered as &quot;&amp;lt;br /&amp;gt;&quot; so that it appears as text, instead of a new line).  The &lt;%= ... %&gt; is not the only delimiter available to us. EJS also provides a number of opening and closing delimiters (&quot;tags&quot;) that control how a value is rendered within the template.  ","version":"Next","tagName":"h2"},{"title":"Delimiters (Tags)​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/ejs-embedded-javaScript-templates#delimiters-tags","content":" &lt;%= ... %&gt; (HTML Escaped) As we have seen, this tag outputs the value into the template (HTML escaped). For example: &lt;br /&gt; will be rendered as: &amp;lt;br /&amp;gt;, when using the tag: &lt;%= someValue %&gt; &lt;%- ... %&gt; (Unescaped) This tag works exactly as the above &lt;%= tag, except the value is not HTML escaped.For example: &lt;br /&gt; will be rendered as: &lt;br /&gt;, when using the tag: &lt;%- someValue %&gt; &lt;%# ... %&gt; (Comment) This tag is used when we wish add a comment to our templates that will not be output in the final HTML, ie: &lt;%# This is a comment that will not be rendered %&gt; &lt;% ... %&gt; (Scriptlet) This is the tag that will enable us to insert logic into our templates (discussed further down). For example, if our &quot;data&quot; object contained an array of colors, ie: ['red','green','blue], we could use the following &quot;scriptlet&quot; tags to render the contents using a &quot;forEach&quot; loop: &lt;% data.colors.forEach((color) =&gt; { %&gt; &lt;%= color %&gt; &lt;% }) %&gt;   info Delimiters that output a value (ie &quot;HTML escaped&quot; / &quot;unescaped&quot;) are also capable of executing JavaScript expressions. For example, if &quot;someValue&quot; is a string, we could use the following code: &lt;%= someValue.toUpperCase() %&gt;  ","version":"Next","tagName":"h3"},{"title":"Includes / \"Partials\"​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/ejs-embedded-javaScript-templates#includes--partials","content":" When using EJS, it is also possible to place reusable blocks of our user interface in separate files, such as a common header or an in-page modal window / dialog box. To achieve this, EJS uses an &quot;include&quot; function that may be used in one of the output tags (ie: &quot;HTML escaped&quot; or &quot;unescaped&quot;, however since these included .ejs files typically use HTML, the &quot;unescaped&quot; delimiter is more commonly used).  To see how this works in practice, we will create a &quot;partials&quot; folder within the &quot;views&quot; folder (this will help us separate the reusable templates, from the &quot;page&quot; templates)  Next, (within the &quot;partials&quot; folder) create a file called &quot;header.ejs&quot;:  &lt;h1&gt;EJS Practice - &lt;%= page %&gt;&lt;/h1&gt; &lt;hr /&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt; | &lt;a href=&quot;/viewData&quot;&gt;View Data&lt;/a&gt; &lt;hr /&gt; &lt;br /&gt;   Notice how our partial template includes a block of reusable HTML as well as an &quot;HTML escaped&quot; tag to render a variable called &quot;page&quot;. To render this template inside another template, we can use the aforementioned &quot;include&quot; function:  File: viewData.ejs  &lt;%- include('partials/header', {page: '/viewData'}) %&gt;   Here, we have used the &quot;unescaped&quot; delimiter to ensure that the HTML within the &quot;partial&quot; is correctly rendered. Additionally, the second parameter contains an object that we an pass to our partial (in this case, the value of the &quot;page&quot; variable)  info Partial views have access to the data in the template in which they are placed. For example, if the &quot;header&quot; partial (above) was placed in the viewData template, it would have access to the &quot;data&quot; object and could render &quot;data.name&quot;, for example  ","version":"Next","tagName":"h3"},{"title":"Logic​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/ejs-embedded-javaScript-templates#logic","content":" Using the &quot;Scriptlet&quot; delimiter (ie: &lt;% ... %&gt;), we can easily insert JavaScript code into our templates. This is one of the key benefits of using EJS:  &quot;We love JavaScript. It's a totally friendly language. All templating languages grow to be Turing-complete. Just cut out the middle-man, and use JS! https://ejs.co  ","version":"Next","tagName":"h2"},{"title":"if / else​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/ejs-embedded-javaScript-templates#if--else","content":" To conditionally render portions of our template (HTML), we can use a simple if / else statement. To get this to work correctly, each &quot;line&quot; of JavaScript code should be placed inside a scriptlet delimiter. For example, say we wish to conditionally show our developer &quot;John&quot;:  let someData = { name: 'John', age: 23, occupation: 'developer', company: 'Scotiabank', visible: true, };   Notice, we have added a &quot;visible&quot; property that we can reference before we render &quot;someData&quot; in our view. Using a simple if / else statement, we can easily hide or show rows in the table:  File: viewData.ejs  &lt;% if (data.visible) { %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= data.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data.age %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data.occupation %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data.company %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } else { %&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;User: '&lt;%= data.name %&gt;' has hidden their information&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt;   ","version":"Next","tagName":"h3"},{"title":"Iterating over Collections​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/ejs-embedded-javaScript-templates#iterating-over-collections","content":" In addition to conditionally rendering portions of our templates, we may also need to display the content of an array / collection. This may be done using the usual constructs, ie &quot;for&quot;, &quot;for...of&quot;, &quot;while&quot;, &quot;forEach()&quot;, etc. For example, if our someData object contained an array of objects:  let someData = [ { name: 'John', age: 23, occupation: 'developer', company: 'Scotiabank', }, { name: 'Sarah', age: 32, occupation: 'manager', company: 'TD', }, ];   we could use the &quot;forEach()&quot; method to display each object in our table:  File: viewData.ejs  &lt;% data.forEach(user=&gt;{ %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= user.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.age %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.occupation %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.company %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% }) %&gt;   Please note that we are not limited to the forEach() loop when iterating over data. As mentioned above, we could also use another construct, such as the &quot;for...of&quot; loop:  &lt;% for (const user of data){ %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= user.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.age %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.occupation %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.company %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt;   ","version":"Next","tagName":"h3"},{"title":"\"Nesting\" Logic​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/ejs-embedded-javaScript-templates#nesting-logic","content":" The &quot;scriptlet&quot; tag is extremely powerful - it let's us inject JavaScript into our views to control how our data is displayed. In the above examples, we have only used single pieces of logic at a time (ie: &quot;if/else&quot;, &quot;forEach()&quot;, etc), but it is also possible that this logic may be &quot;nested&quot;.  For example, maybe each of our &quot;users&quot; in the &quot;someData&quot; array has a &quot;visible&quot; property as well. We would like to render each of the elements in the array, but also hide a user if their visible property is set to false  let someData = [ { name: 'John', age: 23, occupation: 'developer', company: 'Scotiabank', visibility: false, }, { name: 'Sarah', age: 32, occupation: 'manager', company: 'TD', visibility: true, }, ];   File: viewData.ejs  &lt;% for (const user of data){ %&gt; &lt;% if(user.visible){ %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= user.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.age %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.occupation %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.company %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% }else{ %&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;User: '&lt;%= user.name %&gt;' has hidden their information&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt; &lt;% } %&gt;   ","version":"Next","tagName":"h3"},{"title":"Layouts​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingToolsAndFrameworks/Template-Engines/ejs-embedded-javaScript-templates#layouts","content":" EJS does not natively support &quot;layouts&quot;. Typically, the structure of an application using EJS as its template engine will feature a common &quot;header, &quot;footer&quot;, &quot;sidebar&quot;, etc with every page, ie:  &lt;body&gt; &lt;%- include('header') %&gt; &lt;%# Page Content / Data Here %&gt; &lt;%- include('footer') %&gt; &lt;/body&gt;   If you wish to customize the 'header' or 'footer' based on the current page, data can be sent to each of the partials separately. For example, one common task is for a navigation bar within the 'header' to highlight the link for the current page. For example, if the user is currently viewing the &quot;/about&quot; route, then &quot;About&quot; should be highlighted:  File: header.ejs  &lt;h1&gt;EJS Practice - &lt;%= page %&gt;&lt;/h1&gt; &lt;hr /&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;/about&quot;&gt;&lt;strong&gt;About&lt;/strong&gt;&lt;/a&gt; | &lt;a href=&quot;/viewData&quot;&gt;View Data&lt;/a&gt; &lt;hr /&gt; &lt;br /&gt;   To achieve this, we can pass the current route to the partial view. Currently, we are passing this value as &quot;page&quot;:  File: viewData.ejs  &lt;%- include('partials/header', {page: '/viewData'}) %&gt;   Therefore, we can leverage the &quot;unescaped&quot; tag to conditionally highlight each of the options using the &quot;ternary&quot; operator, by checking the &quot;href&quot; attribute against the &quot;page&quot; value:  &lt;h1&gt;EJS Practice - &lt;%= page %&gt;&lt;/h1&gt; &lt;hr /&gt; &lt;a href=&quot;/&quot;&gt;&lt;%- (page==&quot;/&quot;) ? '&lt;strong&gt;Home&lt;/strong&gt;' : 'Home' %&gt;&lt;/a&gt; | &lt;a href=&quot;/about&quot;&gt;&lt;%- (page==&quot;/about&quot;) ? '&lt;strong&gt;About&lt;/strong&gt;' : 'About' %&gt;&lt;/a&gt; | &lt;a href=&quot;/viewData&quot;&gt;&lt;%- (page==&quot;/viewData&quot;) ? '&lt;strong&gt;View Data&lt;/strong&gt;' : 'View Data' %&gt;&lt;/a&gt; &lt;hr /&gt; &lt;br /&gt;   info If you wish to use EJS with full layout support, consider the NPM package: express-ejs-layouts ","version":"Next","tagName":"h2"},{"title":"What is a UI Toolkit / Framework?","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/what-is-a-ui-toolkit-framework","content":"","keywords":"","version":"Next"},{"title":"Popular Frameworks​","type":1,"pageTitle":"What is a UI Toolkit / Framework?","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/what-is-a-ui-toolkit-framework#popular-frameworks","content":" The following is a list of some popular frameworks and how to quickly get started using them. Typically all we need to do is include their CSS / JS files using a CDN, then reference the documentation for some boilerplate, starter code, ie:  &lt;!-- Create a button in Bootstrap using the &quot;Primary&quot; colour --&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;Primary&lt;/button&gt;   ","version":"Next","tagName":"h2"},{"title":"Bootstrap​","type":1,"pageTitle":"What is a UI Toolkit / Framework?","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/what-is-a-ui-toolkit-framework#bootstrap","content":" One of oldest and most popular UI frameworks is &quot;Bootstrap&quot;:  &quot;Powerful, extensible, and feature-packed frontend toolkit. Build and customize with Sass, utilize prebuilt grid system and components, and bring projects to life with powerful JavaScript plugins.&quot;  If we wish to incorporate Bootstrap into our projects, we can link to the files directly using the &quot;jsdelivr&quot; Content Delivery Network (CDN):  &lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; integrity=&quot;sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM&quot; crossorigin=&quot;anonymous&quot; /&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js&quot; integrity=&quot;sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz&quot; crossorigin=&quot;anonymous&quot; &gt;&lt;/script&gt;   caution It is important that we include the CDN links before our own CSS / JS.  ","version":"Next","tagName":"h3"},{"title":"Materialize​","type":1,"pageTitle":"What is a UI Toolkit / Framework?","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/what-is-a-ui-toolkit-framework#materialize","content":" Back in June, 2014 Google introduced &quot;Material Design&quot;:  &quot;Material Design is an adaptable system of guidelines, components, and tools that support the best practices of user interface design. Backed by open-source code, Material Design streamlines collaboration between designers and developers, and helps teams quickly build beautiful products.&quot; https://m3.material.io  A simple way to get started with Material Design is to use &quot;Materialize&quot;, which is described as a &quot;responsive front-end framework based on Material Design&quot;. Essentially, Materialize provides the CSS and JS for components that follow the Material Design guidelines.  To get started using Materialize, we can follow the same strategy as we used for Bootstrap, ie: using the &quot;cloudflare&quot; CDN links directly in our HTML documents:  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css&quot; /&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js&quot;&gt;&lt;/script&gt;   ","version":"Next","tagName":"h3"},{"title":"Bulma​","type":1,"pageTitle":"What is a UI Toolkit / Framework?","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/what-is-a-ui-toolkit-framework#bulma","content":" Another alternative is &quot;Bulma&quot;: It was released in 2016 and has had a number of releases - at the time of writing, Bulma is at 0.9.4.  &quot;Bulma is a free, open source framework that provides ready-to-use frontend components that you can easily combine to build responsive web interfaces. No CSS knowledge required.&quot; https://bulma.io  You will notice that Bulma does not require any JS to run, making it more straightforward to incorporate into existing projects. It also provides a simple &quot;modular&quot; approach to including &quot;only what you need&quot; from the framework.  As with other frameworks on this list, the simplest way to start is to use the minified CSS, available on the &quot;jsdelivr&quot; CDN:  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css&quot; /&gt;   ","version":"Next","tagName":"h3"},{"title":"Starling UI​","type":1,"pageTitle":"What is a UI Toolkit / Framework?","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/what-is-a-ui-toolkit-framework#starling-ui","content":" Starling UI is a lightweight UI toolkit that provides color tokens, typography, buttons, cards, navigation, a grid system, and even a simple modal with optional JavaScript helpers. You can include the entire toolkit or just the components you need.  To get started, you can either include everything:  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://starlingui.netlify.app/sui.css&quot; /&gt;   or just the pieces you need. For example, to include a button:  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://starlingui.netlify.app/utils/color.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://starlingui.netlify.app/pages/components/button/button.css&quot; /&gt; &lt;button class=&quot;sui_btn btn_outline&quot;&gt;Click Me&lt;/button&gt;   ","version":"Next","tagName":"h3"},{"title":"Foundation​","type":1,"pageTitle":"What is a UI Toolkit / Framework?","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/what-is-a-ui-toolkit-framework#foundation","content":" Finally, we should mention &quot;Foundation&quot; - a framework released by &quot;Zurb&quot; back in 2011. It has gone through a number of major releases since then and (at the time of writing) is currently on version 6, released in 2015. Foundation has extensive documentation and while it may be more complex then some of the other frameworks, it has may resources such as &quot;starter projects&quot; and video tutorials to help new users. Interestingly, it also has a version that is used to help design &quot;responsive HTML emails&quot;, which can be cumbersome and difficult.  To get started using it, the simplest way is to use the CDN links:  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/foundation-sites@6.7.5/dist/css/foundation.min.css&quot; crossorigin=&quot;anonymous&quot; /&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/foundation-sites@6.7.5/dist/js/foundation.min.js&quot; crossorigin=&quot;anonymous&quot; &gt;&lt;/script&gt;   ","version":"Next","tagName":"h3"},{"title":"Introduction to Sass​","type":1,"pageTitle":"What is a UI Toolkit / Framework?","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/what-is-a-ui-toolkit-framework#introduction-to-sass","content":" After exploring the documentation for the above frameworks, you will notice that all them make use of something called &quot;Sass&quot;:  &quot;CSS on its own can be fun, but stylesheets are getting larger, more complex, and harder to maintain. This is where a preprocessor can help. Sass has features that don't exist in CSS yet like nesting, mixins, inheritance, and other nifty goodies that help you write robust, maintainable CSS.&quot; https://sass-lang.com/guide  Sass, or &quot;Syntactically Awesome StyleSheets&quot; is a superset of CSS that adds power and elegance to the basic language. It allows you to use variables, nested rules, mixins, modules, and more, all with a fully CSS-compatible syntax. Sass helps keep large stylesheets well-organized as well as getting small stylesheets up and running quickly. This is a natural choice for large CSS frameworks like those mentioned above.  There are two syntaxes available for Sass. The first, known as SCSS (defined using the &quot;.scss&quot; extension) is an extension of the syntax of CSS while the other syntax SASS (defined using the &quot;.sass&quot; extension), provides a more concise way of writing CSS. It uses indentation rather than brackets to indicate nesting of selectors, and newlines rather than semicolons to separate properties.  ","version":"Next","tagName":"h2"},{"title":"Getting Started​","type":1,"pageTitle":"What is a UI Toolkit / Framework?","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/what-is-a-ui-toolkit-framework#getting-started","content":" To get started working with Sass, first create a simple web server using Express, making sure that there is at least one route and a &quot;public&quot; static folder has been configured.  Once this is complete run the following command to install the &quot;sass&quot; command as a &quot;devDependency&quot; (ie: a package that that is only needed for local development and testing.)  npm i -D sass   We require this command because Sass functions as a CSS precompiler - it adds functionality to CSS in a layer above it and we must run a script / program to convert our Sass files into regular CSS so that the browser can interpret it.  With our command correctly installed, we should add a &quot;scss&quot; folder outside the &quot;public&quot; folder (it does not need to be accessed by the client) and create a couple of .scss files (main.scss &amp; _reset.scss):  /scss ↪ main.scss ↪ _reset.scss   Finally, to make sure our new &quot;sass&quot; CLI works to &quot;watch&quot; our .scss files for changes and correctly update a new file: /public/css/main.css, we must add the following &quot;scripts&quot; property to our &quot;package.json&quot; file:  &quot;scripts&quot;: { &quot;build-css&quot;: &quot;sass --no-source-map --watch scss:public/css&quot; }   info From the documentation: &quot;When compiling whole directories, Sass will ignore partial files whose names begin with _. You can use partials to separate out your stylesheets without creating a bunch of unnecessary output files.&quot; This is why we do not get a &quot;_reset.css&quot; file as a result of our build step (below)  Notice how the &quot;build-css&quot; script is set to run &quot;sass&quot; with &quot;scss&quot; as the source and &quot;public/css&quot; as the destination. We also use the --no-source-map and --watch flags to ensure that the command will not generate a source map as well as &quot;watch&quot; our source directory for changes and automatically re-compile on save.  To get sass running, simply execute the command:  npm run build-css   Now, every time we make a change to any file within our /scss directory our Sass will be compiled and the resulting CSS will be saved in the pubic css folder as main.css. We can leave this process running in the background and not have to worry about any additional &quot;compile&quot; steps.  You will know when the process has completed successfully when you see the following green message in the terminal: Compiled scss/main.scss to public/css/main.css.. Similarly, you will know that there was an error compiling your SCSS if you see an &quot;Error&quot; message in the terminal.  ","version":"Next","tagName":"h3"},{"title":"Working with SCSS​","type":1,"pageTitle":"What is a UI Toolkit / Framework?","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/what-is-a-ui-toolkit-framework#working-with-scss","content":" With our script humming along in the background waiting for changes, why don't we try out some of the great features of our new CSS extension language?  Variables​  Think of variables as a way to store information that you want to reuse throughout your stylesheet. You can store things like colors, font stacks, or any CSS value you think you'll want to reuse. Sass uses the $ symbol to make something a variable. Here's an example:  $font-stack: Helvetica, sans-serif; $primary-color: #333; body { font: 100% $font-stack; color: $primary-color; }   When the Sass is processed, it takes the variables we define for the font−stack∗∗and∗∗font-stack** and **font−stack∗∗and∗∗primary-color and outputs normal CSS with our variable values placed in the CSS. This can be extremely powerful when working with brand colors and keeping them consistent throughout the site.  body { font: 100% Helvetica, sans-serif; color: #333; }   Nesting​  When writing HTML you've probably noticed that it has a clear nested and visual hierarchy. CSS, on the other hand, doesn't. Sass will let you nest your CSS selectors in a way that follows the same visual hierarchy of your HTML. Be aware that overly nested rules will result in over-qualified CSS that could prove hard to maintain and is generally considered bad practice. With that in mind, here's an example of some typical styles for a site's navigation:  nav { ul { margin: 0; padding: 0; list-style: none; } li { display: inline-block; } a { display: block; padding: 6px 12px; text-decoration: none; } }   You'll notice that the ul, li, and a selectors are nested inside the nav selector. This is a great way to organize your CSS and make it more readable. When you generate the CSS you'll get something like this:  nav ul { margin: 0; padding: 0; list-style: none; } nav li { display: inline-block; } nav a { display: block; padding: 6px 12px; text-decoration: none; }   Import (Use)​  CSS has an import option that lets you split your CSS into smaller, more maintainable portions. The only drawback is that each time you use @import in CSS it creates another HTTP request. Sass builds on top of the current CSS @import (as @use) but instead of requiring an HTTP request, Sass will take the file that you want to import and combine it with the file you're importing into so you can serve a single CSS file to the web browser.  In our Sass directory, we have two scss files: _reset.scss and main.scss. We want to import _reset.scss into main.scss.  // _reset.scss html, body, ul, ol { margin: 0; padding: 0; }   // main.scss @use '_reset'; body { font: 100% Helvetica, sans-serif; background-color: #efefef; }   Notice we're using @use '_reset'; in the main.scss file. When you import a file you don't need to include the file extension .scss. Sass is smart and will figure it out for you. When you generate the CSS you'll get:  html, body, ul, ol { margin: 0; padding: 0; } body { font: 100% Helvetica, sans-serif; background-color: #efefef; }   Mixins​  Mixins let you make groups of CSS declarations that you want to reuse throughout your site. You can even pass in values to make your mixin more flexible, making it more like a function definition within your CSS. The &quot;Bulma&quot; framework makes use of the following &quot;overlay&quot; mixin which can be used to help position elements on the page using &quot;absolute&quot; positioning (ie a &quot;modal&quot; window):  @mixin overlay($offset: 0) { bottom: $offset; left: $offset; position: absolute; right: $offset; top: $offset; } .modal { @include overlay(150px); }   To create a mixin you use the @mixin directive and give it a name, ie &quot;overlay&quot;. We're also using the variable $offset inside the parentheses so we can pass in an offset of whatever we want (using &quot;0&quot; as the default). After you create your mixin, you can then use it as a CSS declaration starting with @include followed by the name of the mixin. When your CSS is generated it'll look like this:  .modal { bottom: 150px; left: 150px; position: absolute; right: 150px; top: 150px; }   Extend / Inheritance​  This is one of the most useful features of Sass. Using @extend lets you share a set of CSS properties from one selector to another. It helps keep your Sass very DRY (&quot;Don't Repeat Yourself&quot;). In our example we're going to create a simple series of messaging for errors, warnings and successes.  .message { border: 1px solid #ccc; padding: 10px; color: #333; } .success { @extend .message; border-color: green; } .error { @extend .message; border-color: red; } .warning { @extend .message; border-color: yellow; }   What the above code does is allow you to take the CSS properties in .message and apply them to .success, .error, &amp; .warning. The magic happens with the generated CSS, and this helps you avoid having to write multiple class names on HTML elements. This is what it looks like:  .message, .success, .error, .warning { border: 1px solid #cccccc; padding: 10px; color: #333; } .success { border-color: green; } .error { border-color: red; } .warning { border-color: yellow; }   Operators​  Doing math in your CSS is very helpful. Sass has a handful of standard math operators like +, -, *, /, and %. For example we can do the following simple math to calculate widths for an aside &amp; article.  .container { width: 100%; } article[role='main'] { float: left; width: calc(600px / 960px * 100%); // gets 600px as a percentage of 960px } aside[role='complementary'] { float: right; width: calc(300px / 960px * 100%); // gets 300px as a percentage of 960px }   In the above case, the generated CSS will look like:  .container { width: 100%; } article[role='main'] { float: left; width: 62.5%; } aside[role='complementary'] { float: right; width: 31.25%; }  ","version":"Next","tagName":"h3"},{"title":"AJAX Review","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/ajax-review","content":"","keywords":"","version":"Next"},{"title":"AJAX Introduction: The Fetch API​","type":1,"pageTitle":"AJAX Review","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/ajax-review#ajax-introduction-the-fetch-api","content":" In modern browsers, we can use the &quot;Fetch API&quot; to make AJAX requests. Essentially, we can configure a new Request by providing two parameters:  The location of the resourceA set of &quot;options&quot;, (defined using &quot;object literal&quot; notation)  The &quot;location&quot; parameter is simply the URI of the resource, ie: &quot;https://jsonplaceholder.typicode.com/users/&quot;, while the &quot;options&quot; parameter could contain any number of options, including:  The http method, ie: 'POST'The 'body' of the request, ie: JSON.stringify({user:&quot;John Doe&quot;, job:&quot;unknown&quot;})An object consisting of a number of headers, ie: {&quot;Content-Type&quot;: &quot;application/json&quot;}And Many Others  In practice, this would look something like this:  let myRequest = new Request('https://jsonplaceholder.typicode.com/users/', { method: 'POST', body: JSON.stringify({ username: 'jDoe', name: 'John Doe' }), headers: { 'Content-Type': 'application/json', }, });   Once the request is configured, we can &quot;Fetch&quot; the data using &quot;fetch()&quot; with our request. This &quot;fetch&quot; method will return a promise that resolves with a &quot;response&quot; object that has a number of methods, including:  response.text() - which we can use to read the 'response' stream. This method returns a promise that will resolve with text.response.json() - which we can use to read the 'response' stream. This method returns a promise that will resolve with an object.  To execute the request defined above (ie: myRequest), we can wire up the &quot;fetch&quot; using the following code (assuming that our resource is returning JSON-formatted data).  fetch(myRequest) .then((response) =&gt; { return response.json(); }) .then((json) =&gt; { console.log(json); // here is the parsed JSON response });   ","version":"Next","tagName":"h2"},{"title":"AJAX: The Fetch API (Compressed)​","type":1,"pageTitle":"AJAX Review","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/ajax-review#ajax-the-fetch-api-compressed","content":" To save lines and make your code more readable and concise, the above two pieces of code can be combined, ie:  fetch('https://jsonplaceholder.typicode.com/users/', { method: 'POST', body: JSON.stringify({ username: 'jDoe', name: 'John Doe' }), headers: { 'Content-Type': 'application/json' }, }) .then((response) =&gt; response.json()) .then((json) =&gt; { console.log(json); });   info Our code is even shorter if we're simply doing a &quot;GET&quot; request, ie: fetch('https://jsonplaceholder.typicode.com/users/') .then((response) =&gt; response.json()) .then((json) =&gt; { console.log(json); });   ","version":"Next","tagName":"h3"},{"title":"Handling Responses with an \"Error\" Status​","type":1,"pageTitle":"AJAX Review","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/ajax-review#handling-responses-with-an-error-status","content":" If we wish to handle a situation where the fetch fails, we can always add a catch statement at the end of the above code. However, it is important to note that if the response itself was successful (ie a connnection was made and a response was returned), then the &quot;catch&quot; callback code will not be executed even if the response status code indicates an error, ie 500 or 404. To handle these situations, we can leverage a method on the response object callded &quot;ok&quot; (see: response.ok) which will be true if the status code of the response was in the 200 range. Practically speaking, it can be used like this:  fetch('https://jsonplaceholder.typicode.com/unknown') .then((response) =&gt; { // return a rejected promise with the status code of the response if it wasn't &quot;ok&quot; return response.ok ? response.json() : Promise.reject(response.status); }) .then((json) =&gt; { console.log(json); }) .catch((err) =&gt; { console.log(err); });  ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/example-code","content":"Example Code You may download the sample code for this topic here: Web-API-Overview","keywords":"","version":"Next"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/example-code","content":"Example Code You may download the sample code for this topic here: Web-Server-Introduction","keywords":"","version":"Next"},{"title":"HTTP Protocol Overview","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/http-protocol-overview","content":"","keywords":"","version":"Next"},{"title":"HTTP Requests​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/http-protocol-overview#http-requests","content":" ","version":"Next","tagName":"h2"},{"title":"Start line​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/http-protocol-overview#start-line","content":" HTTP requests are messages sent by the client to initiate an action on the server. Their start-line contains of three elements:  An HTTP method that describes the action to be performed:  Method\tDescriptionGET\tThe GET method is used to retrieve information from a specified URI (Universal Resource Identifier) and is assumed to be a safe, repeatable operation by browsers, caches and other HTTP aware components. This means that the operation must have no side effects and GET requests can be re-issued without worrying about the consequences. POST\tThe POST method requests that the target resource process the representation enclosed in the request according to the resource’s own specific semantics. For example, POST is used for the following functions (among others): - Providing a block of data, such as the fields entered into an HTML form, to a data-handling process; - Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles; - Creating a new resource that has yet to be identified by the origin server; - Appending data to a resource’s existing representation(s). PUT\tThe PUT method is used to request that server store the content included in message body at a location specified by the given URL. For example, this might be a file that will be created or replaced. HEAD\tThe HEAD method is identical to GET except that the server MUST NOT send a message body in the response (i.e., the response terminates at the end of the header section). This method can be used for obtaining metadata about the selected representation without transferring the representation data. DELETE\tThe DELETE method requests that the origin server remove the association between the target resource and its current functionality. In effect, this method is similar to the rm command in UNIX: it expresses a deletion operation on the URI mapping of the origin server. CONNECT\tThe CONNECT method requests that the recipient establish a tunnel to the destination origin server identified by the request-target and, if successful, thereafter restrict its behavior to blind forwarding of packets, in both directions, until the tunnel is closed. Tunnels are commonly used to create an end-to-end virtual connection, through one or more proxies, which can then be secured using TLS (Transport Layer Security). OPTIONS\tThe OPTIONS method requests information about the communication options available for the target resource. This method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action. TRACE\tThe TRACE method requests a remote, application-level loop-back of the request message. This is typically used to echo the contents of an HTTP Request back to the requester which can be used for debugging purposes during development.  The request target (this can vary between the different HTTP methods) – for example, this can be: An absolute path, optionally followed by a ‘?’ and a query string. This is the most common form, called origin form, and is used with GET, POST, HEAD, and OPTIONS methods, for example: POST / HTTP 1.1GET /background.png HTTP/1.0HEAD /test.html?query=alibaba HTTP/1.1OPTIONS /anypage.html HTTP/1.0 A complete URL, the absolute form, mostly used with GET when connected to a proxy, for example: GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1 The authority component of an URL, that is the domain name and optionally the port (prefixed by a ‘:’), called the authority form. It is only used with CONNECT when setting up an HTTP tunnel, for example: CONNECT developer.mozilla.org:80 HTTP/1.1 The asterisk form, a simple asterisk (‘*’) used with OPTIONS and representing the server as a whole, for example: OPTIONS * HTTP/1.1 The HTTP version, that defines the structure of the rest of the message, and acts as an indicator of the version to use for the response.  ","version":"Next","tagName":"h3"},{"title":"Headers​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/http-protocol-overview#headers","content":" HTTP headers in a request follow the basic structure of any HTTP header: a case-insensitive string followed by a colon (‘:’) and a value whose structure depends upon the header. The whole header, including the value, consists of one single line, that can be quite long.  There are numerous request headers available. In a request, the headers can be divided into two groups:  Request headers: Provide additional context to a request or add extra logic to how it should be treated by a server (e.g., conditional requests).Representation headers: Sent in a request if the message has a body, and they describe the original form of the message data and any encoding applied. This allows the recipient to understand how to reconstruct the resource as it was before it was transmitted over the network.   (https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages)  ","version":"Next","tagName":"h3"},{"title":"Body​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/http-protocol-overview#body","content":" The last part of a request is its body. Not all requests have one: for example, requests fetching resources (like GET or HEAD) usually don’t need any. Similarly, DELETE or OPTIONS also do not require a body.  Other requests send data in the body to the server in order to update it: this is often the case of POST requests (that can have HTML form data).  ","version":"Next","tagName":"h3"},{"title":"HTTP Responses​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/http-protocol-overview#http-responses","content":" ","version":"Next","tagName":"h2"},{"title":"Status line​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/http-protocol-overview#status-line","content":" The start line of an HTTP response, called the status line, contains the following information:  The protocol version, usually HTTP/1.1A status code beginning with 1, 2, 3, 4 or 5 that provides information such as the success or failure of the request:  Range\tDescription1xx\tInformational: Request received, continuing process. For example, Microsoft IIS (Internet Information Services) initially replies with 100 (Continue) when it receives a POST request and then with 200 (OK) once it has been processed. 2xx\tSuccess: The action was successfully received, understood, and accepted. For example, the 200 (Ok) status code indicates that the request has succeeded. The meaning of “success” varies depending on the HTTP method, for example: GET: The resource has been fetched and is transmitted in the message body, HEAD: The entity headers are in the message body, POST: The resource describing the result of the action is transmitted in the message body, and TRACE: The message body contains the request message as received by the server 3xx\tRedirection: Further action must be taken in order to complete the request. For example, the 302 (Found) status code indicates that the requested resource has been temporarily moved and the browser should issue a request to the URL supplied in the Location response header. 4xx\tClient Error: The request contains bad syntax or cannot be fulfilled. For example, the famous 404 (Not Found) status code indicates that the server can not find requested resource, or is not willing to disclose that one exists. 5xx\tServer Error: The server failed to fulfill an apparently valid request. For example, the 500 (Internal Server Error) status code indicates that the server encountered an unexpected error / condition that prevented it from fulfilling the request.  A status text, purely informational, that is a textual short description of the status code. This helps HTTP messages be more human-readable, for example: HTTP/1.1 404 Not Found  ","version":"Next","tagName":"h3"},{"title":"Headers​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/http-protocol-overview#headers-1","content":" The HTTP header format for responses follow the same basic structure (a case-insensitive string followed by a colon (‘:’) and a value whose structure depends upon the type of the header. The whole header, including the value, stands in one single line)  There are numerous response headers available. In a response, the headers can be divided into two groups:  Response headers: Give additional context about the message or add extra logic to how the client should make subsequent requests. For example, headers like Server include information about the server software, while Date includes when the response was generated. There is also information about the resource being returned, such as its content type (Content-Type), or how it should be cached (Cache-Control).Representation headers: Describe the form of the message data and any encoding applied (if the message has a body). For example, the same resource might be formatted in a particular media type such as XML or JSON, localized to a particular written language or geographical region, and/or compressed or otherwise encoded for transmission. This allows a recipient to understand how to reconstruct the resource as it was before it was transmitted over the network.   (https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages)  ","version":"Next","tagName":"h3"},{"title":"Body​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/http-protocol-overview#body-1","content":" The last part of a response is the body. This is typically a single file of known length (defined by the two headers: “Content-Type” and “Content-Length”) or a single file of unknown length (encoded in chunks with the “Transfer-Encoding” header set to “chunked”. However, not all responses have a body, for example: responses with status code like 201 (Created) or 204 (No Content). ","version":"Next","tagName":"h3"},{"title":"Tailwind CSS & daisyUI","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/tailwind-css-daisyui","content":"","keywords":"","version":"Next"},{"title":"Setting up Tailwind CSS​","type":1,"pageTitle":"Tailwind CSS & daisyUI","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/tailwind-css-daisyui#setting-up-tailwind-css","content":" To begin using Tailwind, we will once again create a simple web server using Express, making sure that there is at least one route and a &quot;public&quot; static folder has been configured.  Once this is complete, run the following command to install the &quot;tailwindcss&quot; command as a &quot;devDependency&quot;:  npm install -D tailwindcss@latest @tailwindcss/cli@latest   With Tailwind CSS correctly installed, we must create a primary css file as our starting point to include Tailwind CSS. To do this, crate a &quot;tailwind.css&quot; file within &quot;/public/css&quot; (ie: /public/css/tailwind.css) with the following code:  @import &quot;tailwindcss&quot;;   ","version":"Next","tagName":"h2"},{"title":"\"Build\" main.css​","type":1,"pageTitle":"Tailwind CSS & daisyUI","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/tailwind-css-daisyui#build-maincss","content":" For the next step (as we did with &quot;SASS&quot;), we must add a &quot;build&quot; command to the &quot;scripts&quot; section of our package.json file:  File: package.json  &quot;scripts&quot;: { &quot;tw:build&quot;: &quot;npx @tailwindcss/cli -i ./public/css/tailwind.css -o ./public/css/main.css --watch&quot; }   To test this out, add the following import statement and HTML to one of your &quot;view&quot; (.&quot;html&quot;) files:  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/main.css&quot; /&gt;   &lt;div class=&quot;w-[150px] h-[80px] shadow-2xl bg-white rounded-lg flex justify-center items-center&quot;&gt; &lt;p class=&quot;text-center&quot;&gt;shadow-2xl&lt;/p&gt; &lt;/div&gt;   Finally, &quot;build&quot; the &quot;main.css&quot; file by executing the command in the Integrated Terminal:  npm run tw:build   Congratulations! You have crated a new main.css file with all of the required Tailwind CSS classes for your view, including &quot;shadow-2xl&quot;, &quot;bg-white&quot;, etc. Now, every time you decide to update any of your &quot;view&quot; files or &quot;tailwind.css&quot;, you can re-run the npm run tw:build command to re-generate your optimized main.css file.  info Tailwind CSS Recommends the Visual Studio Extension &quot;Tailwind CSS IntelliSense&quot;, which has features such as: Autocomplete: Intelligent suggestions for class names, as well as CSS functions and directivesLinting: Highlights errors and potential bugs in both your CSS and your markupHover Preview: See the complete CSS for a Tailwind class name by hovering over it  ","version":"Next","tagName":"h3"},{"title":"Introducing daisyUI​","type":1,"pageTitle":"Tailwind CSS & daisyUI","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/tailwind-css-daisyui#introducing-daisyui","content":" As mentioned above, daisyUI is a &quot;plugin&quot; for Tailwind CSS. It adds UI components while still providing the full flexibility of Tailwind's utility classes:  &quot;[daisyUI is] the most popular component library for Tailwind CSS&quot; &quot;daisyUI adds component class names to Tailwind CSS so you can make beautiful websites faster than ever&quot;. https://daisyui.com  This sounds like the perfect compromise - we get beautifully styled UI components while still having the freedom to use the extensive set of Tailwind's utility classes to configure them and design new components.  ","version":"Next","tagName":"h2"},{"title":"Installing​","type":1,"pageTitle":"Tailwind CSS & daisyUI","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/tailwind-css-daisyui#installing","content":" To get started using daisyUI, the first thing that we need to do is &quot;install&quot; the required packages using NPM:  npm install -D @tailwindcss/typography@latest daisyui@latest   Once this is complete, the next step is to register them as &quot;plugins&quot; in the &quot;tailwind.css&quot; file:  File: /public/css/tailwind.css  @plugin &quot;@tailwindcss/typography&quot;; @plugin &quot;daisyui&quot;;   caution The &quot;@tailwindcss/typography&quot; plugin is recommended by daisyUI and is required if we wish to see text such as headings and paragraphs correctly styled. To read more on this, including using the &quot;prose&quot; class (&quot;that you can slap on any block of vanilla HTML content and turn it into a beautiful, well-formatted document&quot;), see the following link to the documentation: https://daisyui.com/docs/layout-and-typography  This should be all that is required to register daisyUI with Tailwind CSS. To verify that it did indeed work, try adding a component from daisyUI to one of your .html files using main.css. The simplest example is a button - we'll use the &quot;primary&quot; variation:  &lt;button class=&quot;btn btn-primary&quot;&gt;Button&lt;/button&gt;   To test if this worked, all that is needed is to execute another &quot;build&quot; of tailwind, using the previously-configured &quot;tw:build&quot; command:  npm run tw:build   You should now see &quot;.btn&quot; and &quot;.btn-primary&quot; classes added to your main.css, as well as a working purple button in your view!  ","version":"Next","tagName":"h3"},{"title":"Theming​","type":1,"pageTitle":"Tailwind CSS & daisyUI","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/tailwind-css-daisyui#theming","content":" Before we discuss some of the important design patterns and components available from daisyUI, let's quickly discuss how we can modify the &quot;theme&quot; that is used when rendering our components:  &quot;daisyUI comes with a number of themes, which you can use with no extra effort. Each theme defines a set of colors which will be used on all daisyUI elements&quot;  At it's core the various &quot;themes&quot; that daisyUI provides are alternate color schemes and variations on the roundness of corners, thickness and length of shadows, etc. for the provided components. Recall from our &quot;btn-primary&quot; example above: a purple button was rendered on the screen (since this is the default &quot;primary&quot; color). If we were to use one of the built in themes such as &quot;cupcake&quot;, the &quot;primary&quot; color would be a dark cyan and the button would have more rounded edges.  To change the theme used by daisyUI, all that is required is that a named theme from the list of themes be listed in a &quot;themes&quot; property for &quot;daisyui&quot; in the tailwind.css file. For example, if we wish to use the aforementioned &quot;cupcake&quot; theme, we could update our tailwind.css file as follows:  File: /public/css/tailwind.css  @plugin &quot;daisyui&quot; { themes: cupcake; }   Additionally, we must update any &lt;html&gt; elements for pages using the theme, ie: your &quot;view&quot; (&quot;.html&quot;) files to use the &quot;data-theme&quot; property:  &lt;html data-theme=&quot;cupcake&quot;&gt;   ","version":"Next","tagName":"h3"},{"title":"Components​","type":1,"pageTitle":"Tailwind CSS & daisyUI","url":"/WebProgrammingToolsAndFrameworks/UI-Toolkits/tailwind-css-daisyui#components","content":" At the time of writing, DaisyUI ships with a total of 52 Components. The library is extremely extensive and the documentation is both very well written and searchable. If you plan on working with Tailwind CSS, daisyUI is an excellent addition that can greatly speed up your development time and make your apps look professional without having to do any additional design work.  The following is a list of a few key components that are used in most web applications, along with the (.html) code to include them in your views. For additional components and patterns, refer to the official documentation.  caution Do not forget to &quot;build&quot; your Tailwind CSS before testing newly added components / HTML to see the results.  Navbar​  The first component that we will discuss is the &quot;Navbar&quot;. The navbar (short for &quot;navigation bar&quot;) provides a consistent, user friendly and widely recognized way to navigate through a web site / app. To begin using daisyUI's implementation, add the following HTML:  &lt;div class=&quot;navbar bg-base-100&quot;&gt; &lt;div class=&quot;flex-1&quot;&gt; &lt;a class=&quot;btn btn-ghost normal-case text-xl&quot;&gt;daisyUI&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;navbar-center flex&quot;&gt; &lt;ul class=&quot;menu menu-horizontal px-1&quot;&gt; &lt;li&gt;&lt;a&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;details&gt; &lt;summary&gt;Parent&lt;/summary&gt; &lt;ul class=&quot;p-2 bg-base-100 right-0&quot;&gt; &lt;li&gt;&lt;a&gt;Link 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;Link 2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/details&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;   This is a very simple navigation bar using boilerplate code from the documentation. It shows a &quot;daisyUI&quot; logo / link on the left hand side and two navigation links (including a &quot;dropdown&quot; menu). To add new items, we simply modify the unordered list. Features such as &quot;Search Input&quot; and &quot;Icons with indicators&quot; are also supported.  The only issue here is that the menu is not &quot;responsive&quot; (ie: it does not collapse to accommodate smaller devices). To remedy this, we should make the navbar only visible if the viewport is a certain width or larger. If the viewport is smaller than the breakpoint (minimum width), then an alternate navbar should be shown, featuring an icon indicating that the user can click to view the menu items.  To modify the above boilerplate code to make it responsive, we must first change:  &lt;div class=&quot;navbar-center flex&quot;&gt;&lt;/div&gt;   to:  &lt;div class=&quot;navbar-center hidden sm:flex&quot;&gt;&lt;/div&gt;   Next, add the &quot;responsive&quot; version of the navigation bar above the recently-modified &quot;navbar-center&quot; &lt;div&gt;...&lt;/div&gt;, making sure to include the same links / menu items:  &lt;div class=&quot;dropdown&quot;&gt; &lt;label tabindex=&quot;0&quot; class=&quot;btn btn-ghost sm:hidden&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;w-6 h-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;&lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M4 6h16M4 12h16m-7 6h7&quot; /&gt;&lt;/svg&gt; &lt;/label&gt; &lt;ul tabindex=&quot;0&quot; class=&quot;menu menu-sm dropdown-content right-0 mt-3 z-[1] p-2 shadow bg-base-100 rounded-box w-52&quot;&gt; &lt;li&gt;&lt;a&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;details&gt; &lt;summary&gt; Parent &lt;/summary&gt; &lt;ul class=&quot;p-2 bg-base-100&quot;&gt; &lt;li&gt;&lt;a&gt;Link 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;Link 2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/details&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;   This should provide a navigation bar that appears normal if the viewport is larger than the &quot;sm&quot; size (640px), and compressed (ie: converted to a drop-down menu with an appropriate icon) when the viewport is smaller.  caution There is currently an issue where dropdowns do not close when clicking away on some mobile devices (iPhone / IOS) - see: &quot;Dropdown not closing when clicking outside on mobile #824&quot;. At the time of writing, the fix involves setting a negative tabindex on the &lt;body&gt; element, ie: &lt;body tabIndex=&quot;-1&quot;&gt;  Grid System​  Another important feature of any design system is it's &quot;grid&quot; implementation. A grid system will let us place elements on the page that are spaced consistently and are resized / rearranged to accommodate multiple device sizes (ie: &quot;responsive&quot;). Interestingly, daisyUI does not provide it's own grid system, instead relying on Tailwind's excellent implementation.  To get started using the grid system, we will crate a responsive grid that consists of 4 columns for the large size, 2 columns for the medium size, and 1 column for the small size.  &lt;div class=&quot;container mx-auto&quot;&gt; &lt;div class=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4&quot;&gt; &lt;div class=&quot;border-2&quot;&gt;01&lt;/div&gt; &lt;div class=&quot;border-2&quot;&gt;02&lt;/div&gt; &lt;div class=&quot;border-2&quot;&gt;03&lt;/div&gt; &lt;div class=&quot;border-2&quot;&gt;04&lt;/div&gt; &lt;div class=&quot;border-2&quot;&gt;05&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;   You will notice that the grid is also placed within a responsive &quot;container&quot;, which ensures that the grid is given a correct width depending on the viewport size.  info You can specify more that one grid in a container. For example, if you wished to have a large, single column grid above the other items (serving as a title block, etc), you could update the code to use: &lt;div class=&quot;container mx-auto&quot;&gt; &lt;div class=&quot;grid grid-cols-1 mb-4&quot;&gt; &lt;div class=&quot;border-2&quot;&gt;Title&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4&quot;&gt; &lt;div class=&quot;border-2&quot;&gt;01&lt;/div&gt; &lt;div class=&quot;border-2&quot;&gt;02&lt;/div&gt; &lt;div class=&quot;border-2&quot;&gt;03&lt;/div&gt; &lt;div class=&quot;border-2&quot;&gt;04&lt;/div&gt; &lt;div class=&quot;border-2&quot;&gt;05&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;   Cards​  A &quot;Card&quot; is basically a user interface element that serves as a &quot;content container&quot; for a specific item to be presented to the user (ie: a product from a store, or service offered, etc). Cards typically include elements such as an image, title, description, call to action, and often incorporate subheadings or icons.  &quot;A card UI design is an entire interface based largely or exclusively on presenting the user content on cards. The logic behind this is to avoid long texts and render content more scannable. Even though users might not be familiar with the concept of a card from a design point of view – they instantly know how to use UI cards.&quot; https://www.justinmind.com/ui-design/cards  Fortunately, daisyUI has a card component that is ready to be incorporated into our designs:  &lt;div class=&quot;card w-96 bg-base-100 shadow-xl&quot;&gt; &lt;figure&gt; &lt;img class=&quot;w-full&quot; src=&quot;https://placehold.co/375x375?text=[+SHOES+]&quot; alt=&quot;Shoes&quot; /&gt; &lt;/figure&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h2 class=&quot;card-title&quot;&gt;Shoes!&lt;/h2&gt; &lt;p&gt;If a dog chews shoes whose shoes does he choose?&lt;/p&gt; &lt;div class=&quot;card-actions justify-end&quot;&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;Buy Now&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;   info If you wish to position the card as a &quot;grid&quot; item, the &quot;w-96&quot; class can be removed and the entire &quot;card&quot; can be placed within the grid  For other options, such as &quot;responsive&quot;, &quot;custom colors&quot;, etc. please refer to the documentation.  Tables​  If your content is more &quot;tabular&quot; (ie: displayed using tables / columns), such as sports scores, results from an experiment, sales reports, etc. then it's best placed with a styled &quot;table&quot; element.  To achieve this using daisyUI, the documentation recommends placing your table within a &lt;div&gt; element with class overflow-x-auto. Additionally, the &lt;table&gt; element itself should have the class table:  &lt;div class=&quot;overflow-x-auto&quot;&gt; &lt;table class=&quot;table&quot;&gt; &lt;!-- ... --&gt; &lt;/table&gt; &lt;/div&gt;   For other options, such as &quot;striped rows&quot;, &quot;visual elements&quot;, &quot;compact tables&quot;, etc. please refer to the documentation.  Forms​  Finally, we should discuss how form elements are styled using Tailwind CSS / daisyUI. Generally, form controls are styled using a class that matches their type - for example, to style an &lt;input&gt; element the class &quot;input&quot; would be used. Similarly, to style a &lt;select&gt; element the &quot;select&quot; class would be used. This pattern extends to whether or not we wish to style the control with a border (ie, using the styles &quot;input-bordered&quot; and &quot;select-bordered&quot;).  The below HTML snippet captures the major form types: &quot;input&quot;, &quot;textarea&quot;, &quot;select&quot;, &quot;radio&quot; and &quot;checkbox&quot; within a responsive grid that is 3 columns wide.  &lt;form&gt; &lt;div class=&quot;container mx-auto&quot;&gt; &lt;div class=&quot;grid grid-cols-1 md:grid-cols-3 gap-4&quot;&gt; &lt;div&gt; &lt;label class=&quot;label&quot;&gt;&lt;span class=&quot;label-text&quot;&gt;Name&lt;/span&gt;&lt;/label&gt; &lt;input class=&quot;input input-bordered w-full&quot; type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; placeholder=&quot;Enter your name&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label class=&quot;label&quot;&gt;&lt;span class=&quot;label-text&quot;&gt;Message&lt;/span&gt;&lt;/label&gt; &lt;textarea class=&quot;textarea textarea-bordered w-full&quot; id=&quot;message&quot; name=&quot;message&quot; placeholder=&quot;Enter your message&quot; &gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div&gt; &lt;label class=&quot;label&quot;&gt;&lt;span class=&quot;label-text&quot;&gt;Fast Food&lt;/span&gt;&lt;/label&gt; &lt;select class=&quot;select select-bordered w-full&quot;&gt; &lt;option disabled selected&gt;Fast Food&lt;/option&gt; &lt;option&gt;Pizza&lt;/option&gt; &lt;option&gt;Hamburger&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class=&quot;label cursor-pointer justify-normal&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;pets&quot; class=&quot;radio&quot; /&gt; &lt;span class=&quot;label-text px-2&quot;&gt;Dogs&lt;/span&gt; &lt;/label&gt; &lt;label class=&quot;label cursor-pointer justify-normal&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;pets&quot; class=&quot;radio&quot; checked /&gt; &lt;span class=&quot;label-text px-2&quot;&gt;Cats&lt;/span&gt; &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label class=&quot;label cursor-pointer justify-normal&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;active&quot; class=&quot;checkbox&quot; /&gt; &lt;span class=&quot;label-text px-2&quot;&gt;Active&lt;/span&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt;  ","version":"Next","tagName":"h3"},{"title":"JavaScript Object Notation (JSON)","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/javascript-object-notation-json","content":"","keywords":"","version":"Next"},{"title":"Converting JSON to an Object​","type":1,"pageTitle":"JavaScript Object Notation (JSON)","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/javascript-object-notation-json#converting-json-to-an-object","content":" let myJSONStr = '{&quot;users&quot;:[{&quot;userId&quot;:1,&quot;fName&quot;:&quot;Joe&quot;,&quot;lName&quot;:&quot;Smith&quot;},{&quot;userId&quot;:2,&quot;fName&quot;:&quot;Jeffrey&quot;,&quot;lName&quot;:&quot;Sherman&quot;},{&quot;userId&quot;:3,&quot;fName&quot;:&quot;Shantell&quot;,&quot;lName&quot;:&quot;McLeod&quot;}]}'; // Convert to An Object: let myObj = JSON.parse(myJSONStr); // Access the 3rd user (Shantell McLeod) console.log(myObj.users[2].fName); // Shantell   ","version":"Next","tagName":"h2"},{"title":"Converting an Object to JSON​","type":1,"pageTitle":"JavaScript Object Notation (JSON)","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/javascript-object-notation-json#converting-an-object-to-json","content":" let myObj = { users: [ { userId: 1, fName: 'Joe', lName: 'Smith' }, { userId: 2, fName: 'Jeffrey', lName: 'Sherman' }, { userId: 3, fName: 'Shantell', lName: 'McLeod' }, ], }; let myJSON = JSON.stringify(myObj); console.log(myJSON); // Outputs: '{&quot;users&quot;:[{&quot;userId&quot;:1,&quot;fName&quot;:&quot;Joe&quot;,&quot;lName&quot;:&quot;Smith&quot;},{&quot;userId&quot;:2,&quot;fName&quot;:&quot;Jeffrey&quot;,&quot;lName&quot;:&quot;Sherman&quot;},{&quot;userId&quot;:3,&quot;fName&quot;:&quot;Shantell&quot;,&quot;lName&quot;:&quot;McLeod&quot;}]}'   ","version":"Next","tagName":"h2"},{"title":"Caveats When Using JSON​","type":1,"pageTitle":"JavaScript Object Notation (JSON)","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/javascript-object-notation-json#caveats-when-using-json","content":" The JSON format works exceptionally well to &quot;serialize&quot; (convert an object in memory to a byte / string representation) and &quot;deserialize&quot; (converting back to an object in memory). However, there are certain things that cannot be encoded to JavaScript Object Notation:  ","version":"Next","tagName":"h2"},{"title":"Object Instances​","type":1,"pageTitle":"JavaScript Object Notation (JSON)","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/javascript-object-notation-json#object-instances","content":" Instances of objects in memory cannot be stored in a JSON format. For example, consider the following &quot;product&quot; object:  let product = { name: 'Pencil', price: 3.95, added: new Date('December 17, 1995 03:24:00'), };   Since the &quot;added&quot; property is an instance of the Date object, we can invoke methods such as &quot;toLocalStimeString()&quot;:  console.log(product.added.toLocaleTimeString('fr-CA')); // 03 h 24 min 00 s   However, if we convert the product to JSON and back, we lose this ability:  // convert to JSON let productJSON = JSON.stringify(product); // restore (convert to object) let productFromJSON = JSON.parse(productJSON); console.log(productFromJSON.added.toLocaleTimeString('fr-CA')); // TypeError: productFromJSON.added.toLocaleTimeString is not a function   This issue occurs because during the conversion to JSON, the Date object was implicitly converted to a string:  { &quot;name&quot;: &quot;Pencil&quot;, &quot;price&quot;: 3.95, &quot;added&quot;: &quot;1995-12-17T08:24:00.000Z&quot; }   ","version":"Next","tagName":"h3"},{"title":"Functions (Methods)​","type":1,"pageTitle":"JavaScript Object Notation (JSON)","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/javascript-object-notation-json#functions-methods","content":" Functions (&quot;methods&quot;) that exist on the object also will not convert to JSON. For example:  let counter = { current: 0, increase: function () { this.current++; }, }; console.log(counter.current); // 0 counter.increase(); console.log(counter.current); // 1   Once again, if we attempt to convert this object to JSON and back, we lose the &quot;increase()&quot; function:  // convert to JSON let counterJSON = JSON.stringify(counter); // restore (convert to object) let counterFromJSON = JSON.parse(counterJSON); console.log(counterFromJSON.current); // 0 counterFromJSON.increase(); // TypeError: counterFromJSON.increase is not a function   In this case, this issue occurs because during the conversion to JSON, the &quot;increase&quot; function was not included:  { &quot;current&quot;: 0 }   info For more information on how values are &quot;stringified&quot;, refer to the MDN documentation on &quot;JSON.stringify()&quot; ","version":"Next","tagName":"h3"},{"title":"API Introduction & Implementation","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/api-introduction-and-implementation","content":"","keywords":"","version":"Next"},{"title":"Route Configuration​","type":1,"pageTitle":"API Introduction & Implementation","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/api-introduction-and-implementation#route-configuration","content":" Before we think about getting any kind of persistent storage involved however, let's first see how we can configure all of our routes in our server to allow for CRUD operations on a simple collection of users in the format  {userId: number, fName: string, lName: string}   Route\tHTTP Method\tDescription/api/users\tGET\tGet all the users /api/users\tPOST\tCreate a user /api/users/:userId\tGET\tGet a single user /api/users/:userId\tPUT\tUpdate a user with new information /api/users/:userId\tDELETE\tDelete a user  When these routes are applied to our Express server code, we get something that looks like this:  const express = require('express'); const app = express(); const HTTP_PORT = process.env.PORT || 8080; app.get('/api/users', (req, res) =&gt; { res.send({ message: 'fetch all users' }); }); app.post('/api/users', (req, res) =&gt; { res.send({ message: 'add a user' }); }); app.get('/api/users/:userId', (req, res) =&gt; { res.send({ message: `get user with Id: ${req.params.userId}` }); }); app.put('/api/users/:userId', (req, res) =&gt; { res.send({ message: `update User with Id: ${req.params.userId}` }); }); app.delete('/api/users/:userId', (req, res) =&gt; { res.send({ message: `delete User with Id: ${req.params.userId}` }); }); // setup http server to listen on HTTP_PORT app.listen(HTTP_PORT, () =&gt; { console.log(`Express http server listening on: ${HTTP_PORT}`); });   Here, we have made use of the request object's params method to identify the specific user that needs to be fetched, updated or deleted based on the URL alone. In a sense, what we're allowing here is for the URL + HTTP Method to act as a way of querying the data source, as /api/users/3, /api/users/4923 or even /api/users/twelve will all be accepted. They may not necessarily return valid data, but the routes will be found by our server and we can attempt to preform the requested operation.  ","version":"Next","tagName":"h2"},{"title":"AJAX Testing (View)​","type":1,"pageTitle":"API Introduction & Implementation","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/api-introduction-and-implementation#ajax-testing-view","content":" Now that we have all of the routes for our API in place, let's create a &quot;view&quot; that will make AJAX requests to test our API functionality. To begin, create a views folder and add the file index.html. This will be a simple HTML page consisting of 5 buttons (each corresponding to a piece of functionality in our API) and some simple JavaScript to make an AJAX request.  However, since we are serving this file from the same server that our API is on, we will need to add some additional code to our server file; specifically:  const path = require('path');   and  app.get('/', (req, res) =&gt; { res.sendFile(path.join(__dirname, '/views/index.html')); });   Finally - our server is setup and ready to serve the index.html file at our main route (&quot;/&quot;). Our next step is to add our client-side logic / JS to the index.html file. Here, we hard-code some requests to the API and output their results to the web console to make sure they function correctly:  &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;API Test&lt;/title&gt; &lt;script&gt; function makeAJAXRequest(method, url, body) { fetch(url, { method: method, body: JSON.stringify(body), // if missing 'body', 'undefined' is returned headers: { 'Content-Type': 'application/json' } }) .then(response =&gt; response.json()) .then(json =&gt; { console.log(json); }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Test the API by outputting to the browser console:&lt;/p&gt; &lt;!-- Get All Users --&gt; &lt;button type=&quot;button&quot; onclick='makeAJAXRequest(&quot;GET&quot;, &quot;/api/users&quot;)'&gt;Get All Users&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;!-- Add New User --&gt; &lt;button type=&quot;button&quot; onclick='makeAJAXRequest(&quot;POST&quot;, &quot;/api/users&quot;, {fName: &quot;Bob&quot;, lName: &quot;Jones&quot;})'&gt;Add New User&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;!-- Get User By Id --&gt; &lt;button type=&quot;button&quot; onclick='makeAJAXRequest(&quot;GET&quot;, &quot;/api/users/2&quot;)'&gt;Get User&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;!-- Update User By Id --&gt; &lt;button type=&quot;button&quot; onclick='makeAJAXRequest(&quot;PUT&quot;, &quot;/api/users/2&quot;, {fName: &quot;Wanda&quot;, lName: &quot;Smith&quot;})'&gt;Update User&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;!-- Delete User By Id --&gt; &lt;button type=&quot;button&quot; onclick='makeAJAXRequest(&quot;DELETE&quot;, &quot;/api/users/2&quot;)'&gt;Delete User&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;   ","version":"Next","tagName":"h2"},{"title":"Adding Data (JSON)​","type":1,"pageTitle":"API Introduction & Implementation","url":"/WebProgrammingToolsAndFrameworks/Web-API-Overview/api-introduction-and-implementation#adding-data-json","content":" Once you have entered the above code, save the changes and try running the server locally - you will see that All of the routes tested return a JSON formatted message. This confirms that our Web API will correctly respond to AJAX requests made by the client. Additionally, If you open the Network tab (Google Chrome) before initiating one of the calls to Update or Add a New User, you will see that our request is also carrying a payload of information, ie:    If we wish to capture this information in our routes (so that we can make the appropriate updates to our data source), we must make some small modifications to our server.js file and individual routes (ie: POST to &quot;/api/users&quot; &amp; PUT to &quot;/api/users/:userId&quot;). The first thing that we must do is incorporate middleware to parse the incoming data, ie:  app.use(express.json());   This should allow our routes to access data passed to our API using the req.body property. More specifically, we can update our POST &amp; PUT routes to use req.body to fetch the new / updated fName and lName properties:  app.post('/api/users', (req, res) =&gt; { res.send({ message: `add the user: ${req.body.fName} ${req.body.lName}` }); });   and  app.put('/api/users/:userId', (req, res) =&gt; { res.send({ message: `update User with Id: ${req.params.userId} to ${req.body.fName} ${req.body.lName}` }); });   If we try running the server to test the API again, we will see that the messages returned back from the server correctly echo the data sent to the API. We now have everything that we need to preform simple CRUD operations via AJAX on a data source using a web service. The only thing missing is the data store itself.  caution If we want to allow the API to respond to requests from outside the domain (this is what https://jsonplaceholder.typicode.com does), we will have to enable Cross-Origin Resource Sharing (CORS) - see the third-party CORS middleware ","version":"Next","tagName":"h2"},{"title":"Modules & Node Package Manager","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/modules-node-package-manager","content":"","keywords":"","version":"Next"},{"title":"Modules​","type":1,"pageTitle":"Modules & Node Package Manager","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/modules-node-package-manager#modules","content":" Recall way back in the Introduction, the concept of &quot;Built-In Modules / 'require()'&quot; was discussed:  &quot;By using the global 'require' function, we have loaded a code &quot;module&quot; which contains code and logic that we can use in our own solutions.&quot;  We used this to gain access to some of the built in logic that ships with Node, including: 'fs', 'path' and 'readline'.  ","version":"Next","tagName":"h2"},{"title":"Writing Modules​","type":1,"pageTitle":"Modules & Node Package Manager","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/modules-node-package-manager#writing-modules","content":" We can also create our own modules that work the same way, by making use of a global “module” object – which isn’t truly “global” in the same sense as “console”, but instead global to each of your modules, which are located in separate .js files. For example, consider the two following files (modEx1.js: the main file that Node will execute, and message.js: the file containing the module):  file ./modEx1.js  let message = require('./modules/message'); message.writeMessage('Hello World!'); message.readMessage();   file: ./modules/message.js  // NOTE: Node.js wraps the contents of this file in a function: // (function (exports, require, module, __filename, __dirname) { ... }); // so that we have access to the working file/directory names as well // as creating an isolated scope for the module, so that our // variables are not global. let localFunction = () =&gt; { // a function local to this module }; let localMessage = ''; module.exports.writeMessage = (msg) =&gt; { localMessage = msg; }; module.exports.readMessage = () =&gt; { console.log(`${localMessage} from ${__filename}`); };   Executing the code in modEx1.js (ie: node modEx1.js) should output:  “Hello World” from …  where … is the absolute location of the message.js file in your system, for example: /Users/pat/Desktop/Seneca/modules/message.js  Notice how our “message” module uses the exports property of the “module” object to store functions and data that we want to be accessible in the object returned from the require(“./modules/message”); function call from modEx1.js. Generally speaking, if you want to add anything to the object returned by “require” for your module, it’s added to the module.exports object from within your module. In this case, we only added two functions (readMessage() and writeMessage()).  Using this methodology, we can safely create reusable code in an isolated way that can easily be added (plugged in) to another .js file.  ","version":"Next","tagName":"h3"},{"title":"NPM – Node Package Manager​","type":1,"pageTitle":"Modules & Node Package Manager","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/modules-node-package-manager#npm--node-package-manager","content":" The Node Package Manager is a core piece of the module based Node ecosystem. The package manager allows us to install and manage 3rd party modules, available from https://www.npmjs.com within our own applications.  From the npm documentation:  npm is the world's largest software registry. Open source developers from every continent use npm to share and borrow packages, and many organizations use npm to manage private development as well. npm consists of three distinct components: the websitethe Command Line Interface (CLI)the registry Use the website to discover packages, set up profiles, and manage other aspects of your npm experience. For example, you can set up organizations to manage access to public or private packages. The CLI runs from a terminal, and is how most developers interact with npm. The registry is a large public database of JavaScript software and the meta-information surrounding it.  The CLI is installed by default when you install Node. From the command line you can run ‘npm’ with various commands to download and remove packages for use with your Node applications. When you have installed a package from npm you use it in the same way as using your own modules like above, with the require() function.  All npm packages that you install locally for your application will be installed in a node_modules folder in your project folder.  While there are over 60 &quot;npm&quot; commands available, the ones that we will most commonly use in this course are as follows:  Command\tDescriptionnpm install [Module Name]\tinstall is used to install a package from the npm repository so that you can use it with your application. ie: let express = require(&quot;express&quot;); npm uninstall [module name]\tuninstall does exactly what you would think, it uninstalls a module from the node_modules folder and your application will no longer be able to require() it. npm init\tcreate a new package.json file for a fresh application. More on this part later. npm prune\tThe prune command will look through your package.json file and remove any npm modules that are installed that are not required for your project. More on this part later. npm list\tShow a list of all packages installed for use by this application.  ","version":"Next","tagName":"h2"},{"title":"Globally installing packages​","type":1,"pageTitle":"Modules & Node Package Manager","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/modules-node-package-manager#globally-installing-packages","content":" Every so often, you will want to install a package globally. Installing a package globally means you will install it like an application on your computer which you can run from the command line, not use it in your application code. For example, some npm packages are tools that are used as part of your development process on your application:  One example is the migrate package which allows you to write migration scripts for your application that can migrate your data in your database and keep track of which files have been run.  Another example is grunt-cli so that you can run grunt commands from the command line to do things like setup tasks for running unit tests or checking for formatting errors in code before pushing up new code to a repository.  A third example is bower. Bower is a package manager similar to npm but typically used for client side package management. To install a package globally you just add the -g switch to your npm install command. For example:  npm install bower -g   Globally installed packages do not get installed in your node_modules folder and instead are installed in a folder in your user directory. The folder used for global packages varies for Windows, Mac, and Linux. See the documentation if you need to find globally installed packages on your machine.  ","version":"Next","tagName":"h3"},{"title":"package.json explained​","type":1,"pageTitle":"Modules & Node Package Manager","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/modules-node-package-manager#packagejson-explained","content":" The Node Package Manager is great. It provides an easy way to download reusable packages or publish your own for other developers to use. However, there are a few problems with sharing modules and using other modules, once you want to work on an application with someone else. For example:  How are you going to make sure everyone working on your project has all the packages the application requires? How are you going to make sure everyone has the same version of all those packages? Finally, how are you going to handle updating a package and making sure everyone else on your project updates as well?  This is where the package.json file comes in.  The package.json file is a listing of all the packages your application requires and also which versions are required. It provides a simple way for newcomers to your project to get started easily and stay up to date when packages get updated.  The npm documentation for the package.json file has all the information you will need as you begin building applications in node.js  Let’s look at how we can generate a package.json file using the npm init command from within your project's folder (in this case: &quot;/Users/pat/Desktop/Seneca/&quot;):  $ npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See `npm help init` for definitive documentation on these fields and exactly what they do. Use `npm install &lt;pkg&gt;` afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. package name: (seneca) version: (1.0.0) description: entry point: (index.js) test command: git repository: keywords: author: license: (ISC) About to write to /Users/pat/Desktop/Seneca/package.json: { &quot;name&quot;: &quot;seneca&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; }   If you try running this command yourself, you will see that the process is interactive, ie: you will be prompted to enter everything from the &quot;package name&quot; to the &quot;license&quot;. Any values that you see in brackets &quot;()&quot; are default values and will be accepted if you press &quot;Enter&quot;.  Once this process is done, you will see that you have a new file created in your project called package.json. In the above case, it will look like this:  { &quot;name&quot;: &quot;seneca&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; }   Once generated, you can edit it if you decide to change the name or version (for example). Once you decide to add packages to your app you can simply install the package with npm install. This will save the package and version into the package.json file for you so that when others want to work on your app, they will have the package.json file and can use npm install to install all the required dependencies with the right version. Think of package.json as a checklist for your application for all of its dependencies. ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/example-code","content":"Example Code You may download the sample code for this topic here: Working-With-Forms","keywords":"","version":"Next"},{"title":"Simple Web Server using Express.js","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/simple-web-server-using-expressjs","content":"","keywords":"","version":"Next"},{"title":"Project Structure​","type":1,"pageTitle":"Simple Web Server using Express.js","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/simple-web-server-using-expressjs#project-structure","content":" To get started working with Node.js and Express, we should create a new folder for our application (ie: &quot;MyServer&quot;, as used in the below example). Once this is completed, open it in Visual Studio Code and create the following directory structure by adding &quot;public&quot; and &quot;views&quot; folders as well as a &quot;server.js&quot; file:  /MyServer ↪ /public ↪ /views ↪ server.js   Next, we must open the integrated terminal and create the all-important &quot;package.json&quot; file at the root of our &quot;MyServer&quot; folder, using the command &quot;npm init&quot;.  info You will be using all of the default options when creating your package.json file  Once this is complete, you should have a new package.json file in your MyServer folder that looks like the following:  { &quot;name&quot;: &quot;myserver&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;server.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;node server.js&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; }   ","version":"Next","tagName":"h2"},{"title":"Express.js​","type":1,"pageTitle":"Simple Web Server using Express.js","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/simple-web-server-using-expressjs#expressjs","content":" Express.js is described as:  &quot;a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.&quot;  Essentially, it is a Node module that takes a lot of the leg work out of creating a framework to build a website. It is extremely popular in the node.js community with a multitude of developers using it to build websites. It is a proven way to build flexible web applications quickly and easily.  To use it in our project we need to use &quot;npm&quot; to install it. From the integrated terminal in Visual Studio code, enter the command:  npm i express   (where &quot;i&quot; is shorthand for the &quot;install&quot; command).  Once this is complete, you should see that your &quot;package.json&quot; file has a new entry that looks like the following (your version may differ from the below):  &quot;dependencies&quot;: { &quot;express&quot;: &quot;^4.18.2&quot; }   You will also notice that a 2nd file was created called &quot;package-lock.json&quot;:  The purpose of package-lock.json is to ensure that the same dependencies are installed consistently across different environments, such as development and production environments. It also helps to prevent issues with installing different package versions, which can lead to conflicts and errors. https://www.atatus.com/blog/package-json-vs-package-lock-json/#package-lock-json  Finally, we also now have the aforementioned &quot;node_modules&quot; folder, which not only contains an &quot;express&quot; folder, but also folders for all of the other modules that &quot;express&quot; depends upon, such as &quot;cookie&quot;, &quot;encodeurl&quot;, &quot;http-errors&quot;, etc.  To begin using Express.js, we must first &quot;require&quot; it in our server.js file and execute the code to start our server. As a starting point, you may use the following boilerplate code:  File: server.js  const express = require('express'); // &quot;require&quot; the Express module const app = express(); // obtain the &quot;app&quot; object const HTTP_PORT = process.env.PORT || 8080; // assign a port // start the server on the port and output a confirmation to the console app.listen(HTTP_PORT, () =&gt; console.log(`server listening on: ${HTTP_PORT}`));   The above code will be used in nearly every server written using &quot;Express&quot; in these notes. As mentioned above, it &quot;requires&quot; the Express module, which is then invoked as a function to get an &quot;app&quot; object, which is used to start our server on a given HTTP Port. The reason that the HTTP_PORT constant is defined as process.env.PORT || 8080 is because when we move our server online, it will be assigned a different port, using a &quot;PORT&quot; environment variable.  If we now want to start our server, we can simply execute the &quot;server.js&quot; file using node:  node --watch server.js   info The &quot;--watch&quot; flag will cause Node to run in &quot;watch&quot; mode, which will restart the process when a change is detected  If you open a browser to: http://localhost:8080, you should see the following message:  Cannot GET /   Congratulations! Your web server is up and running! Unfortunately, we don't have any &quot;routes&quot; (ie: paths to pages / resources) defined yet, so the Express framework automatically generated a 404 error for the path that we tried to access (ie: GET /)  info To stop the server from running, you may use the Ctrl+C command from the integrated terminal in Visual Studio Code  ","version":"Next","tagName":"h2"},{"title":"Simple 'GET' Routes​","type":1,"pageTitle":"Simple Web Server using Express.js","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/simple-web-server-using-expressjs#simple-get-routes","content":" As you have seen from running our server, not much is happening. Even if we try to navigate around to other paths such as &quot;http://localhost:8080/about&quot; (thereby making a &quot;GET&quot; request to the &quot;/about&quot; path (route)), we will keep getting the same 404 error: &quot;Cannot GET&quot;. This is because we have not defined any &quot;GET&quot; routes within our server.  To fix this, we must write code in our server.js file to correctly respond to these types of requests. This can be accomplished using the &quot;app&quot; object, that was used to start our server. If we wish to respond to a &quot;GET&quot; request, we must invoke a &quot;GET&quot; function and provide the target path as well as a &quot;callback&quot; function to handle the request. For example, if we wish to respond to a &quot;GET&quot; request on the &quot;/&quot; route, we would write the following code before the call to app.listen();  app.get('/', (req, res) =&gt; { res.send('Hello World!'); });   Here, we have specified a callback function to be executed when our server encounters a &quot;GET&quot; request for the &quot;/&quot; route. It will be invoked with the following parameters:  &quot;req&quot;: The &quot;request&quot; object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on.&quot;res&quot;: &quot;The &quot;response&quot; object represents the HTTP response that an Express app sends when it gets an HTTP request  In the above case, we use the &quot;res&quot; object's &quot;send&quot; method to send a response back to the client.  If we wish to have a second route, all we have to do is add another call to &quot;app.get()&quot; with the new path. This is how we will define any path &quot;route&quot; that we wish our server to respond to, when it encounters a &quot;GET&quot; request from a web client (ie: web browser):  app.get('/about', (req, res) =&gt; { res.send('About the Company'); });   Now, we should be able to navigate to both: http://localhost:8080 and http://localhost:8080/about and see the text sent by our server.  ","version":"Next","tagName":"h3"},{"title":"Returning .html Files​","type":1,"pageTitle":"Simple Web Server using Express.js","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/simple-web-server-using-expressjs#returning-html-files","content":" Returning plain text is fine to test if our routes are configured properly, however if we want to start making web applications, we should be returning valid HTML documents. To get started, we will create two simple .html files within the &quot;views&quot; folder:  File: /MyServer/views/home.html  &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Home&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome Home&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;/about&quot;&gt;About the Company&lt;/a&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;   File: /MyServer/views/about.html  &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;About&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;About the Company&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Back Home&lt;/a&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;   Next, we must update our route definitions to return these documents instead of the simple messages: &quot;Hello World!&quot; and &quot;About the Company&quot;. To achieve this, we will be using the &quot;sendFile()&quot; method of the &quot;res&quot; object, instead of &quot;send()&quot;.  For &quot;sendFile()&quot; to function correctly, we must provide an absolute path to the file we wish to send as a parameter to the function. As you know, we cannot hard-code this path into our server.js, as this path will differ depending on which machine is executing the code - for example: the service the app is deployed on, vs. your local computer.  This is where knowledge of the built-in &quot;path&quot; module and the __dirname global come into play.  At the top of your server file, we will require &quot;path&quot;;  const path = require('path');   Next, we can update our routes to use &quot;sendFile()&quot; as follows:  res.sendFile(path.join(__dirname, '/views/someFile.html'));   where &quot;someFile.html&quot; would be any file that you wish to send back to the client, from your &quot;views&quot; folder, ie: &quot;home.html&quot; or &quot;about.html&quot;. We use path.join() to safely join the &quot;__dirname&quot; path with the local path to the file. Together, this results in an absolute path that is not tied to a specific machine.  ","version":"Next","tagName":"h3"},{"title":"CSS & Images​","type":1,"pageTitle":"Simple Web Server using Express.js","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/simple-web-server-using-expressjs#css--images","content":" Now that we know how to send complete HTML files back to the client, the next step is including &quot;static&quot; resources, ie: images, CSS, etc. So far, if we wish to respond to a request from a client we must have an explicit &quot;route&quot; configured. For example, the &quot;/about&quot; route only works because we have defined the corresponding app.get(&quot;/about&quot;, ...) function call. What happens when a request for a static resources is requested? Do we have to have a specific root configured for every resource? Thankfully, the answer is no.  Using Express, we can identify a specific folder as &quot;static&quot; and any valid requests for resources contained within that folder are automatically sent back to the client with a 200 status code.  Using our existing project structure, we can use the &quot;public&quot; folder as our static folder and place any static resources in there. For example, if we want a custom CSS file, we could place it in:  /MyServer ↪ /public ↪ /css ↪ site.css   We could then link to it in our HTML documents the code:  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/site.css&quot; /&gt;   info The same pattern would work for images as well, ie: /MyServer ↪ /public ↪ /img ↪ banner.jpg &lt;img src=&quot;/img/banner.jpg&quot; alt=&quot;site banner&quot; /&gt;   Notice how we do not include &quot;/public&quot; in the href (or src) properties. This is because we will mark &quot;/public&quot; as the official &quot;static&quot; folder and all requests must made to resources within the folder. To accomplish this in our server.js file, we can add the following code above the other app.get() function calls:  app.use(express.static('public'));   Here, we have used &quot;express.static()&quot; - a built-in middleware function (explained later in these notes) to mark the &quot;public&quot; directory as static. With this code in place, whenever a request is sent to our server, Express will first check to see if the requested resource exists in the &quot;public&quot; folder, before checking our other routes.  ","version":"Next","tagName":"h3"},{"title":"Public Hosting (Vercel)​","type":1,"pageTitle":"Simple Web Server using Express.js","url":"/WebProgrammingToolsAndFrameworks/Web-Server-Introduction/simple-web-server-using-expressjs#public-hosting-vercel","content":" As a final exercise, review the documentation on &quot;Getting Started with Vercel&quot; and see if you can get the server running online! ","version":"Next","tagName":"h2"},{"title":"Processing URL Encoded Form Data","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/processing-url-encoded-form-data","content":"","keywords":"","version":"Next"},{"title":"Body Parsing Middleware​","type":1,"pageTitle":"Processing URL Encoded Form Data","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/processing-url-encoded-form-data#body-parsing-middleware","content":" As mentioned in the Middleware / Built-In Middleware discussion, we require some &quot;preprocessing&quot; on the &quot;req&quot; object, before we can access the form data in our routes. For example, if we were to submit the form now, the data sent would look something like this:  fullName=John+Smith&amp;blogEntry=Cool+Blog&amp;pet=cat&amp;transportation=car&amp;transportation=bus&amp;fastFood=pizza&amp;active=on&amp;productID=193774   While it does contain the data from the form, it is very difficult to work with and requires manual parsing of the string. Instead, we would prefer an object in memory:  { fullName: &quot;John Smith&quot;, blogEntry: &quot;Cool Blog&quot;, pet: &quot;cat&quot;, transportation: [ &quot;car&quot;, &quot;bus&quot; ], fastFood: &quot;pizza&quot;, active: &quot;on&quot;, productID: &quot;193774&quot; }   This is where &quot;Middleware&quot; comes in, ie: perform some processing on the HTTP Request &quot;body&quot; data, before sending it to our route handlers in the &quot;req&quot; object.  To achieve this, we can use the built-in middleware: express.urlencoded():  app.use(express.urlencoded({ extended: true }));   ","version":"Next","tagName":"h2"},{"title":"Writing The Route Handler​","type":1,"pageTitle":"Processing URL Encoded Form Data","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/processing-url-encoded-form-data#writing-the-route-handler","content":" In the example above, the form &quot;action&quot; attribute is set to &quot;/addEntry&quot;. If the form were to be submitted now, Express would return a &quot;404&quot; error with a response containing the text &quot;Cannot POST /addEntry&quot;.  To remedy this, create a &quot;POST&quot; route for &quot;/addEntry&quot;:  app.post('/addEntry', (req, res) =&gt; { res.send(req.body); });   once the &quot;/addEntry&quot; route is in place (beneath our &quot;express.urlencoded()&quot; middleware), we can try submitting the form again. This time, we should see the form data rendered as JSON in the browser.  ","version":"Next","tagName":"h2"},{"title":"Special Consideration (\"checkbox\")​","type":1,"pageTitle":"Processing URL Encoded Form Data","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/processing-url-encoded-form-data#special-consideration-checkbox","content":" As previously mentioned in the &quot;checkbox&quot; section of the &quot;HTML Form Elements Review&quot;, checkboxes submit the string &quot;on&quot; when checked and undefined when unchecked. Instead, we would prefer that the value be true or false. As a simple fix for this, we can add the following code:  req.body.active = req.body.active ? true : false;   Here, we see if the &quot;active&quot; value is truthy (ie: not false, 0, -0, 0n, &quot;&quot;, null, undefined, or NaN) and if it is, set it explicitly to &quot;true&quot;. If the value is &quot;falsy&quot; (ie: undefined), then set it explicitly to &quot;false&quot;.  app.post('/addEntry', (req, res) =&gt; { req.body.active = req.body.active ? true : false; res.send(req.body); });  ","version":"Next","tagName":"h3"},{"title":"HTML Form Elements Review","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/html-form-elements-review","content":"","keywords":"","version":"Next"},{"title":"Form​","type":1,"pageTitle":"HTML Form Elements Review","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/html-form-elements-review#form","content":" The form element serves as the primary container for housing your form, including user inputs and the submit button. It has several attributes that control its behavior, with the most common ones being 'enctype', 'method', and 'action'.  The enctype is the encoding type. If you are working with forms that have file uploads that accompany the form data, this value should be set to: multipart/form-data, otherwise the default is application/x-www-form-urlencoded. The 'method' specifies which HTTP verb to use when making the submission request (ie: &quot;GET: or &quot;POST&quot;). Finally, the 'action' attribute is the URL / route that the form will send the request to once it has been submitted.  &lt;form method=&quot;post&quot; enctype=&quot;application/x-www-form-urlencoded&quot; action=&quot;https://httpbin.org/post&quot;&gt; &lt;!-- ... --&gt; &lt;/form&gt;   info In the above example, &quot;enctype&quot; may be omitted since &quot;application/x-www-form-urlencoded&quot; is the default value for &quot;enctype&quot;  ","version":"Next","tagName":"h2"},{"title":"Input​","type":1,"pageTitle":"HTML Form Elements Review","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/html-form-elements-review#input","content":" The input element creates a single-line text box by default (ie: the default value for the 'type' attribute is text):  &lt;input type=&quot;text&quot; name=&quot;fullName&quot; /&gt;   caution We must ensure that every form control includes a &quot;name&quot; field, which will be used to identify the form value, when submitted.  There are also a multitude of additional interactive input 'types' that may be used, such as:  color: Elements of type=&quot;color&quot; provide a user interface element that lets a user specify a color, either by using a visual color picker interface or by entering the color into a text field in #rrggbb hexadecimal format. date: Elements of type=&quot;date&quot; create input fields that let the user enter a date, either with a textbox that validates the input or a special date picker interface. time: Elements of type=&quot;time&quot; create input fields designed to let the user easily enter a time (hours and minutes, and optionally seconds). email: Elements of type=&quot;email&quot; are used to let the user enter and edit an email address, or, if the multiple attribute is specified, a list of email addresses. number: Elements of type=&quot;number&quot; are used to let the user enter a number. They include built-in validation to reject non-numerical entries. range: Elements of type=&quot;range&quot; let the user specify a numeric value which must be no less than a given value, and no more than another given value. The precise value, however, is not considered important. This is typically represented using a slider or dial control rather than a text entry box like the number input type. file: Elements of type=&quot;file&quot; let the user choose one or more files from their device storage. Once chosen, the files can be uploaded to a server using form submission, or manipulated using JavaScript code and the File API.  ","version":"Next","tagName":"h2"},{"title":"Textarea​","type":1,"pageTitle":"HTML Form Elements Review","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/html-form-elements-review#textarea","content":" The textarea element is much like an &lt;input type='text'&gt; input, except it allows multiple lines of text. Essentially, it is a text box that has space to add a larger quantity of text, instead of just a single line of text. The textarea is useful for capturing user input that would typically be long and detailed or several sentences long.  &lt;textarea name=&quot;blogEntry&quot;&gt;&lt;/textarea&gt;   ","version":"Next","tagName":"h2"},{"title":"Select​","type":1,"pageTitle":"HTML Form Elements Review","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/html-form-elements-review#select","content":" The select element serves as a &quot;dropdown list&quot; of option elements for users to choose from. Used without any attributes, it behaves exactly like a dropdown list and only permits the user to select 1 (one) &quot;option&quot;. With the addition of the &quot;multiple&quot; attribute, we can allow the user to select more than one option. We can also specify a &quot;size&quot; attribute, to show more than a single option at a time - this will work for both &lt;select&gt; and &lt;select multiple&gt; elements. When submitted, the value is the text in the &quot;value&quot; attribute for the selected option. When multiple options are selected, an array of &quot;value&quot; attributes are submitted, ie: [&quot;car&quot;, &quot;bus&quot;].  &lt;select name=&quot;pet&quot;&gt; &lt;option value=&quot;&quot;&gt;-- Please choose an option --&lt;/option&gt; &lt;option value=&quot;dog&quot;&gt;Dog&lt;/option&gt; &lt;option value=&quot;cat&quot;&gt;Cat&lt;/option&gt; &lt;option value=&quot;hamster&quot;&gt;Hamster&lt;/option&gt; &lt;option value=&quot;parrot&quot;&gt;Parrot&lt;/option&gt; &lt;/select&gt; &lt;select multiple name=&quot;transportation&quot;&gt; &lt;option value=&quot;car&quot;&gt;Car&lt;/option&gt; &lt;option value=&quot;motorcycle&quot;&gt;Motorcycle&lt;/option&gt; &lt;option value=&quot;bus&quot;&gt;Bus&lt;/option&gt; &lt;option value=&quot;jet&quot;&gt;Private Jet&lt;/option&gt; &lt;/select&gt;   ","version":"Next","tagName":"h2"},{"title":"Checkbox​","type":1,"pageTitle":"HTML Form Elements Review","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/html-form-elements-review#checkbox","content":" The checkbox is actually another &quot;type&quot; of input element. These are rendered as boxes that when clicked, become marked as &quot;checked&quot; and are rendered with a check mark. When submitted, the values are either &quot;on&quot; (for checked), or undefined if left unchecked.  &lt;input type=&quot;checkbox&quot; name=&quot;active&quot; /&gt; Active   ","version":"Next","tagName":"h2"},{"title":"Radio Button​","type":1,"pageTitle":"HTML Form Elements Review","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/html-form-elements-review#radio-button","content":" The radio button is similar to &quot;checkbox&quot; in that it is also a &quot;type&quot; of input. However, radio buttons are used when you wish to present a list of options for the user. When grouped together by using the same &quot;name&quot; attribute, they are &quot;mutually-exclusive&quot; (ie: checking one radio button in the group, will automatically deselect the previously checked radio button). When submitted, the value sent is the text in the &quot;value&quot; attribute for the checked radio button.  &lt;input type=&quot;radio&quot; name=&quot;fastFood&quot; value=&quot;hamburger&quot; /&gt; Hamburger &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;fastFood&quot; value=&quot;pizza&quot; /&gt; Pizza &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;fastFood&quot; value=&quot;sandwich&quot; /&gt; Sandwich &lt;br /&gt;   ","version":"Next","tagName":"h2"},{"title":"Label​","type":1,"pageTitle":"HTML Form Elements Review","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/html-form-elements-review#label","content":" The label element is used to provide a label for a form control. You can use the label's 'for' attribute to make the label clickable to focus its associated input (identified by a unique &quot;id&quot;). Alternatively, you can wrap the label text and form control inside a parent &quot;label&quot; element. This adds a nice touch of usability to forms and can make it easier to focus on / interact with areas associated with a label.  &lt;label for=&quot;fullName&quot;&gt;Full Name&lt;/label&gt;&lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;fullName&quot; id=&quot;fullName&quot; /&gt; &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;active&quot; /&gt; Active&lt;/label&gt;   ","version":"Next","tagName":"h2"},{"title":"Hidden​","type":1,"pageTitle":"HTML Form Elements Review","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/html-form-elements-review#hidden","content":" The hidden input type is used to include data that cannot be seen or modified by users when a form is submitted. For example, &quot;the ID of the content that is currently being ordered or edited, or a unique security token&quot;.  &lt;input type=&quot;hidden&quot; name=&quot;productID&quot; value=&quot;193774&quot; /&gt;   ","version":"Next","tagName":"h2"},{"title":"Submit​","type":1,"pageTitle":"HTML Form Elements Review","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/html-form-elements-review#submit","content":" Every form element should contain a &quot;submit&quot; button that will start the process of submitting the form. This typically includes generating an HTTP request using the method identified in the &quot;method&quot; attribute, and sending it to the destination in the &quot;action&quot; attribute. The encoding of the data in the request is controlled by the &quot;enctype&quot; attribute.  A submit button can be created by either using a input element with type=&quot;submit&quot; or a button with type=&quot;submit&quot;.  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;!-- or --&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;  ","version":"Next","tagName":"h2"},{"title":"Processing Multipart Form Data","type":0,"sectionRef":"#","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/processing-multipart-form-data","content":"","keywords":"","version":"Next"},{"title":"Processing the Data with Middleware​","type":1,"pageTitle":"Processing Multipart Form Data","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/processing-multipart-form-data#processing-the-data-with-middleware","content":" Recall, when working with url-encoded data, we had to use &quot;Middleware&quot; (specifically the built-in middleware: express.urlencoded()) to process the data and deliver it in a format that we can process. This is also the case for &quot;multipart/form-data&quot;, however there are no available built-in middleware functions that we can use. Instead, we will use the popular third-party middleware: &quot;Multer&quot;  info Multer is a node.js middleware for handling multipart/form-data, which is primarily used for uploading files. It is written on top of busboy for maximum efficiency. Multer will not process any form which is not multipart (multipart/form-data).  To get started using Multer, we will need to install it:  npm install multer   Next, we must require the module and configure the middleware, ie:  const multer = require('multer');   ","version":"Next","tagName":"h2"},{"title":"Default (Simple) configuration​","type":1,"pageTitle":"Processing Multipart Form Data","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/processing-multipart-form-data#default-simple-configuration","content":" To begin, we will use the default configuration for Multer. All that is required is a &quot;dest&quot; property that defines where the files will go once uploaded. In this case, we will use the folder &quot;uploads/&quot;:  const upload = multer({ dest: 'uploads/' });   ","version":"Next","tagName":"h3"},{"title":"Writing The Route Handler​","type":1,"pageTitle":"Processing Multipart Form Data","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/processing-multipart-form-data#writing-the-route-handler","content":" With our middleware in place, we can now write our route handler for the route defined in our &quot;action&quot; attribute: &quot;/uploadEntry&quot;. When using Multer, we not only have access to the &quot;req.body&quot; property to get the data submitted in the form, but also a &quot;req.file&quot; property to get information about the uploaded file:  app.post('/uploadEntry', upload.single('avatar'), (req, res) =&gt; { res.send({ body: req.body, file: req.file }); });   Notice how we apply the middleware on the specific route, rather than using &quot;app.use()&quot;. Additionally, since we're uploading a single image, we invoke the &quot;single&quot; method, passing the &quot;name&quot; attribute for our &lt;input type=&quot;file&quot;&gt; (ie: &quot;avatar&quot;).  If we try submitting the form again, we should see a result in the browser with both the form and file upload information (ie: &quot;req.body&quot; &amp; &quot;req.file&quot;).  While this does indeed work and the file is uploaded to the correct destination (the &quot;uploads&quot; folder, as specified), we do not have any control over how the file is named. Additionally, we lose the file extension associated with the file. To gain more control over the file upload, we will need to perform some additional configuration.  ","version":"Next","tagName":"h2"},{"title":"Additional Configuration (diskStorage)​","type":1,"pageTitle":"Processing Multipart Form Data","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/processing-multipart-form-data#additional-configuration-diskstorage","content":" In order to customize the filename of the upload, we will need to use the &quot;diskStorage&quot; option when we configure our &quot;upload&quot; middleware. Here, instead of creating &quot;upload&quot; using multer({ dest: 'uploads/' });, we will use the following &quot;diskStorage&quot; configuration:  const storage = multer.diskStorage({ destination: 'uploads/', filename: function (req, file, cb) { cb(null, Date.now() + path.extname(file.originalname)); }, }); const upload = multer({ storage: storage });   Here, we specify the filename to be a current date, using &quot;Date.now()&quot;, ie:  The number of milliseconds elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC.  We also retain the current extension using path.extname() from the &quot;path&quot; module: const path = require(&quot;path&quot;);  ","version":"Next","tagName":"h2"},{"title":"Ephemeral / Read-Only File Systems​","type":1,"pageTitle":"Processing Multipart Form Data","url":"/WebProgrammingToolsAndFrameworks/Working-With-Forms/processing-multipart-form-data#ephemeral--read-only-file-systems","content":" As a final note, it's important to consider that many cloud-based hosting providers either have an &quot;ephemeral&quot; file system (ie: data is not persisted across deploys and restarts) or the file system is read-only. In this case, if we wish to persist file uploads, we could use a library like &quot;streamifier&quot; to create a readable stream of the file data, rather than store it. We could then pass the data to a free service like &quot;Cloudinary&quot; to host the file.  For more information, see the Cloudinary documentation on Uploading assets / Upload data stream ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}